msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2014-09-08 06:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ./doc/high-availability-guide/ch_controller.xml:8(title)
msgid "Cloud controller cluster stack"
msgstr ""

#: ./doc/high-availability-guide/ch_controller.xml:10(para)
msgid "The cloud controller runs on the management network and must talk to all other services."
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_network.xml:8(title)
msgid "OpenStack network nodes"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_network.xml:10(para)
msgid "OpenStack network nodes contain:"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_network.xml:13(para)
msgid "neutron DHCP agent"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_network.xml:18(para)
msgid "neutron L2 agent"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_network.xml:23(para)
msgid "Neutron L3 agent"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_network.xml:28(para)
msgid "neutron metadata agent"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_network.xml:33(para)
msgid "neutron lbaas agent"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_network.xml:39(para)
msgid "The neutron L2 agent does not need to be highly available. It has to be installed on each Data Forwarding Node and controls the virtual networking drivers as Open vSwitch or Linux Bridge. One L2 agent runs per node and controls its virtual interfaces. That’s why it cannot be distributed and highly available."
msgstr ""

#: ./doc/high-availability-guide/ch_pacemaker.xml:8(title)
msgid "The Pacemaker cluster stack"
msgstr ""

#: ./doc/high-availability-guide/ch_pacemaker.xml:10(para)
msgid "OpenStack infrastructure high availability relies on the <link href=\"http://www.clusterlabs.org\">Pacemaker</link> cluster stack, the state-of-the-art high availability and load balancing stack for the Linux platform. Pacemaker is storage and application-agnostic, and is in no way specific to OpenStack."
msgstr ""

#: ./doc/high-availability-guide/ch_pacemaker.xml:15(para)
msgid "Pacemaker relies on the <link href=\"http://www.corosync.org\">Corosync</link> messaging layer for reliable cluster communications. Corosync implements the Totem single-ring ordering and membership protocol. It also provides UDP and InfiniBand based messaging, quorum, and cluster membership to Pacemaker."
msgstr ""

#: ./doc/high-availability-guide/ch_pacemaker.xml:20(para)
msgid "Pacemaker interacts with applications through <emphasis>resource agents</emphasis> (RAs), of which it supports over 70 natively. Pacemaker can also easily use third-party RAs. An OpenStack high-availability configuration uses existing native Pacemaker RAs (such as those managing MySQL databases or virtual IP addresses), existing third-party RAs (such as for RabbitMQ), and native OpenStack RAs (such as those managing the OpenStack Identity and Image Services)."
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_rabbitmq.xml:8(title)
msgid "RabbitMQ"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_rabbitmq.xml:10(para)
msgid "RabbitMQ is the default AMQP server used by many OpenStack services. Making the RabbitMQ service highly available involves the following steps:"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_rabbitmq.xml:14(para) ./doc/high-availability-guide/ha_aa_rabbitmq/section_install_rabbitmq.xml:7(title)
msgid "Install RabbitMQ"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_rabbitmq.xml:19(para)
msgid "Configure RabbitMQ for HA queues"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_rabbitmq.xml:24(para)
msgid "Configure OpenStack services to use Rabbit HA queues"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:8(title)
msgid "Introduction to OpenStack High Availability"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:10(para)
msgid "High Availability systems seek to minimize two things:"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:13(para)
msgid "<emphasis role=\"strong\">System downtime</emphasis> — occurs when a <emphasis>user-facing</emphasis> service is unavailable beyond a specified maximum amount of time, and"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:17(para)
msgid "<emphasis role=\"strong\">Data loss</emphasis> — accidental deletion or destruction of data."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:21(para)
msgid "Most high availability systems guarantee protection against system downtime and data loss only in the event of a single failure. However, they are also expected to protect against cascading failures, where a single failure deteriorates into a series of consequential failures."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:22(para)
msgid "A crucial aspect of high availability is the elimination of single points of failure (SPOFs). A SPOF is an individual piece of equipment or software which will cause system downtime or data loss if it fails. In order to eliminate SPOFs, check that mechanisms exist for redundancy of:"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:25(para)
msgid "Network components, such as switches and routers"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:30(para)
msgid "Applications and automatic service migration"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:35(para)
msgid "Storage components"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:40(para)
msgid "Facility services such as power, air conditioning, and fire protection"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:45(para)
msgid "Most high availability systems will fail in the event of multiple independent (non-consequential) failures. In this case, most systems will protect data over maintaining availability."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:46(para)
msgid "High-availability systems typically achieve uptime of 99.99% or more, which roughly equates to less than an hour of cumulative downtime per year. In order to achieve this, high availability systems should keep recovery times after a failure to about one to two minutes, sometimes significantly less."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:47(para)
msgid "OpenStack currently meets such availability requirements for its own infrastructure services, meaning that an uptime of 99.99% is feasible for the OpenStack infrastructure proper. However, OpenStack <emphasis>does</emphasis><emphasis>not</emphasis> guarantee 99.99% availability for individual guest instances."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:48(para)
msgid "Preventing single points of failure can depend on whether or not a service is stateless."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:51(title)
msgid "Stateless vs. Stateful services"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:53(para)
msgid "A stateless service is one that provides a response after your request, and then requires no further attention. To make a stateless service highly available, you need to provide redundant instances and load balance them. OpenStack services that are stateless include nova-api, nova-conductor, glance-api, keystone-api, neutron-api and nova-scheduler."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:54(para)
msgid "A stateful service is one where subsequent requests to the service depend on the results of the first request. Stateful services are more difficult to manage because a single action typically involves more than one request, so simply providing additional instances and load balancing will not solve the problem. For example, if the Horizon user interface reset itself every time you went to a new page, it wouldn’t be very useful. OpenStack services that are stateful include the OpenStack database and message queue."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:55(para)
msgid "Making stateful services highly available can depend on whether you choose an active/passive or active/active configuration."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:59(title)
msgid "Active/Passive"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:61(para)
msgid "In an active/passive configuration, systems are set up to bring additional resources online to replace those that have failed. For example, OpenStack would write to the main database while maintaining a disaster recovery database that can be brought online in the event that the main database fails."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:62(para)
msgid "Typically, an active/passive installation for a stateless service would maintain a redundant instance that can be brought online when required. Requests may be handled using a virtual IP address to facilitate return to service with minimal reconfiguration required."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:63(para)
msgid "A typical active/passive installation for a stateful service maintains a replacement resource that can be brought online when required. A separate application (such as Pacemaker or Corosync) monitors these services, bringing the backup online as necessary."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:67(title)
msgid "Active/Active"
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:69(para)
msgid "In an active/active configuration, systems also use a backup but will manage both the main and redundant systems concurrently. This way, if there is a failure the user is unlikely to notice. The backup system is already online, and takes on increased load while the main system is fixed and brought back online."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:70(para)
msgid "Typically, an active/active installation for a stateless service would maintain a redundant instance, and requests are load balanced using a virtual IP address and a load balancer such as HAProxy."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:71(para)
msgid "A typical active/active installation for a stateful service would include redundant services with all instances having an identical state. For example, updates to one instance of a database would also update all other instances. This way a request to one instance is the same as a request to any other. A load balancer manages the traffic to these systems, ensuring that operational systems always handle the request."
msgstr ""

#: ./doc/high-availability-guide/ch_intro.xml:72(para)
msgid "These are some of the more common ways to implement these high availability architectures, but they are by no means the only ways to do it. The important thing is to make sure that your services are redundant, and available; how you achieve that is up to you. This document will cover some of the more common options for highly available systems."
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:8(title)
msgid "OpenStack High Availability Guide"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:12(firstname)
msgid "Florian"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:13(surname)
msgid "Haas"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:15(email)
msgid "florian@hastexo.com"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:17(orgname)
msgid "hastexo"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:21(year)
msgid "2012"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:22(year)
msgid "2013"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:23(year)
msgid "2014"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:24(holder)
msgid "OpenStack Contributors"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:26(releaseinfo)
msgid "current"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:27(productname)
msgid "OpenStack"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:31(remark)
msgid "Copyright details are filled in by the template."
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:35(para)
msgid "This guide describes how to install, configure, and manage OpenStack for high availability."
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:40(date)
msgid "2014-05-16"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:44(para)
msgid "Conversion to Docbook."
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:50(date)
msgid "2014-04-17"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:54(para)
msgid "Minor cleanup of typos, otherwise no major revisions for Icehouse release."
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:61(date)
msgid "2012-01-16"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:65(para)
msgid "Organizes guide based on cloud controller and compute nodes."
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:71(date)
msgid "2012-05-24"
msgstr ""

#: ./doc/high-availability-guide/bk-ha-guide.xml:75(para)
msgid "Begin trunk designation."
msgstr ""

#: ./doc/high-availability-guide/ch_network.xml:8(title)
msgid "Network controller cluster stack"
msgstr ""

#: ./doc/high-availability-guide/ch_network.xml:10(para)
msgid "The network controller sits on the management and data network, and needs to be connected to the Internet if an instance will need access to the Internet."
msgstr ""

#: ./doc/high-availability-guide/ch_network.xml:12(para)
msgid "Both nodes should have the same hostname since the Networking scheduler will be aware of one node, for example a virtual router attached to a single L3 node."
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_haproxy.xml:8(title)
msgid "HAProxy nodes"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_haproxy.xml:10(para)
msgid "HAProxy is a very fast and reliable solution offering high availability, load balancing, and proxying for TCP and HTTP-based applications. It is particularly suited for web sites crawling under very high loads while needing persistence or Layer 7 processing. Supporting tens of thousands of connections is clearly realistic with today’s hardware."
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_haproxy.xml:14(para)
msgid "For installing HAProxy on your nodes, you should consider its <link href=\"http://haproxy.1wt.eu/#docs\">official documentation</link>. Also, you have to consider that this service should not be a single point of failure, so you need at least two nodes running HAProxy."
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_haproxy.xml:17(para)
msgid "Here is an example for HAProxy configuration file:"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_haproxy.xml:157(para)
msgid "After each change of this file, you should restart HAProxy."
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_controllers.xml:8(title)
msgid "OpenStack controller nodes"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_controllers.xml:10(para)
msgid "OpenStack controller nodes contain:"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_controllers.xml:13(para)
msgid "All OpenStack API services"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_controllers.xml:18(para)
msgid "All OpenStack schedulers"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_controllers.xml:23(para)
msgid "Memcached service"
msgstr ""

#: ./doc/high-availability-guide/part_active_passive.xml:8(title)
msgid "HA using active/passive"
msgstr ""

#: ./doc/high-availability-guide/ch_api.xml:8(title)
msgid "API node cluster stack"
msgstr ""

#: ./doc/high-availability-guide/ch_api.xml:10(para)
msgid "The API node exposes OpenStack API endpoints onto external network (Internet). It must talk to the cloud controller on the management network."
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_db.xml:8(title)
msgid "Database"
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_db.xml:10(para)
msgid "The first step is installing the database that sits at the heart of the cluster. When we talk about High Availability, we talk about several databases (for redundancy) and a means to keep them synchronized. In this case, we must choose the MySQL database, along with Galera for synchronous multi-master replication."
msgstr ""

#: ./doc/high-availability-guide/ch_ha_aa_db.xml:14(para)
msgid "The choice of database isn’t a foregone conclusion; you’re not required to use MySQL. It is, however, a fairly common choice in OpenStack installations, so we’ll cover it here."
msgstr ""

#: ./doc/high-availability-guide/part_active_active.xml:8(title)
msgid "HA using active/active"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_galera_monitoring.xml:7(title)
msgid "Galera monitoring scripts"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_galera_monitoring.xml:9(para)
msgid "(Coming soon)"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:7(title)
msgid "MySQL with Galera"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:9(para)
msgid "Rather than starting with a vanilla version of MySQL, and then adding Galera, you will want to install a version of MySQL patched for wsrep (Write Set REPlication) from <link href=\"https://launchpad.net/codership-mysql/0.7\">https://launchpad.net/codership-mysql/0.7</link>. The wsrep API is suitable for configuring MySQL High Availability in OpenStack because it supports synchronous replication."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:14(para)
msgid "Note that the installation requirements call for careful attention. Read the guide <link href=\"https://launchpadlibrarian.net/66669857/README-wsrep\">https://launchpadlibrarian.net/66669857/README-wsrep</link> to ensure you follow all the required steps."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:19(title)
msgid "Installing Galera through a MySQL version patched for wsrep:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:22(para)
msgid "Download Galera from <link href=\"https://launchpad.net/galera/+download\">https://launchpad.net/galera/+download</link>, and install the *.rpms or *.debs, which takes care of any dependencies that your system doesn’t already have installed."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:29(para)
msgid "Adjust the configuration:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:32(para)
msgid "In the system-wide <filename>my.conf</filename> file, make sure mysqld isn’t bound to 127.0.0.1, and that <filename>/etc/mysql/conf.d/</filename> is included. Typically you can find this file at <filename>/etc/my.cnf</filename>:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:40(para)
msgid "When adding a new node, you must configure it with a MySQL account that can access the other nodes. The new node must be able to request a state snapshot from one of the existing nodes:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:45(para)
msgid "Specify your MySQL account information in <filename>/etc/mysql/conf.d/wsrep.cnf</filename>:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:51(para)
msgid "Connect as root and grant privileges to that user:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:57(para)
msgid "Remove user accounts with empty user names because they cause problems:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:63(para)
msgid "Set up certain mandatory configuration options within MySQL itself. These include:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:74(para)
msgid "Check that the nodes can access each other through the firewall. Depending on your environment, this might mean adjusting iptables, as in:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:84(para)
msgid "This might also mean configuring any NAT firewall between nodes to allow direct connections. You might need to disable SELinux, or configure it to allow mysqld to listen to sockets at unprivileged ports."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:89(para)
msgid "Now you’re ready to create the cluster."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:92(title)
msgid "Create the cluster"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:94(para)
msgid "In creating a cluster, you first start a single instance, which creates the cluster. The rest of the MySQL instances then connect to that cluster:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:99(title)
msgid "An example of creating the cluster:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:102(para)
msgid "Start on the first node having IP address <literal>10.0.0.10</literal> by executing the command:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:110(para)
msgid "Connect to that cluster on the rest of the nodes by referencing the address of that node, as in:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:117(para)
msgid "You also have the option to set the <literal>wsrep_cluster_address</literal> in the <filename>/etc/mysql/conf.d/wsrep.cnf</filename> file, or within the client itself. (In fact, for some systems, such as MariaDB or Percona, this may be your only option.)"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:123(title)
msgid "An example of checking the status of the cluster."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:126(para)
msgid "Open the MySQL client and check the status of the various parameters:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_ha_aa_db_mysql_galera.xml:133(para)
msgid "You should see a status that looks something like this:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_other_ways_to_provide_a_highly_available_database.xml:7(title)
msgid "Other ways to provide a highly available database"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_db/section_other_ways_to_provide_a_highly_available_database.xml:9(para)
msgid "MySQL with Galera is by no means the only way to achieve database HA. MariaDB (<link href=\"https://mariadb.org/\">https://mariadb.org/</link>) and Percona (<link href=\"http://www.percona.com/\">http://www.percona.com/</link>) also work with Galera. You also have the option to use PostgreSQL, which has its own replication, or another database HA option."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_network/section_run_neutron_l3_agent.xml:7(title)
msgid "Run neutron L3 agent"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_network/section_run_neutron_l3_agent.xml:9(para)
msgid "The neutron L3 agent is scalable thanks to the scheduler that allows distribution of virtual routers across multiple nodes. But there is no native feature to make these routers highly available. At this time, the Active / Passive solution exists to run the Neutron L3 agent in failover mode with Pacemaker. See the Active / Passive section of this guide."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_network/section_run_neutron_metadata_agent.xml:7(title)
msgid "Run neutron metadata agent"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_network/section_run_neutron_metadata_agent.xml:9(para)
msgid "There is no native feature to make this service highly available. At this time, the Active / Passive solution exists to run the neutron metadata agent in failover mode with Pacemaker. See the Active / Passive section of this guide."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_network/section_run_neutron_dhcp_agent.xml:7(title)
msgid "Run neutron DHCP agent"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_network/section_run_neutron_dhcp_agent.xml:9(para)
msgid "OpenStack Networking service has a scheduler that lets you run multiple agents across nodes. Also, the DHCP agent can be natively highly available. For details, see <link href=\"http://docs.openstack.org/trunk/config-reference/content/app_demo_multi_dhcp_agents.html\">OpenStack Configuration Reference</link>."
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:7(title)
msgid "Highly available Block Storage API"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:9(para)
msgid "Making the Block Storage (cinder) API service highly available in active / passive mode involves"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:12(para)
msgid "Configure Block Storage to listen on the VIP address,"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:17(para)
msgid "managing Block Storage API daemon with the Pacemaker cluster manager,"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:22(para) ./doc/high-availability-guide/api/section_glance_api.xml:23(para) ./doc/high-availability-guide/api/section_keystone.xml:23(para)
msgid "Configure OpenStack services to use this IP address."
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:28(para)
msgid "Here is the <link href=\"http://docs.openstack.org/trunk/install-guide/install/apt/content/ch_cinder.html\">documentation</link> for installing Block Storage service."
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:34(title)
msgid "Add Block Storage API resource to Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:36(para) ./doc/high-availability-guide/api/section_glance_api.xml:35(para) ./doc/high-availability-guide/api/section_neutron_server.xml:35(para) ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:27(para) ./doc/high-availability-guide/api/section_keystone.xml:35(para) ./doc/high-availability-guide/network/section_highly_available_neutron_metadata_agent.xml:15(para) ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:19(para) ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:19(para)
msgid "First of all, you need to download the resource agent to your system:"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:40(para)
msgid "You can now add the Pacemaker configuration for Block Storage API resource. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:47(para) ./doc/high-availability-guide/api/section_glance_api.xml:45(para) ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:37(para) ./doc/high-availability-guide/controller/section_rabbitmq.xml:191(para) ./doc/high-availability-guide/controller/section_mysql.xml:203(para) ./doc/high-availability-guide/network/section_highly_available_neutron_metadata_agent.xml:26(para) ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:30(para)
msgid "This configuration creates"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:50(para)
msgid "<literal>p_cinder-api</literal>, a resource for manage Block Storage API service"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:54(para)
msgid "<literal>crm configure</literal> supports batch input, so you may copy and paste the above into your live pacemaker configuration, and then make changes as required. For example, you may enter <literal>edit p_ip_cinder-api</literal> from the <literal>crm configure</literal> menu and edit the resource to match your preferred virtual IP address."
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:59(para)
msgid "Once completed, commit your configuration changes by entering <literal>commit</literal> from the <literal>crm configure</literal> menu. Pacemaker will then start the Block Storage API service, and its dependent resources, on one of your nodes."
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:65(title)
msgid "Configure Block Storage API service"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:67(para)
msgid "Edit <filename>/etc/cinder/cinder.conf</filename>:"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:80(title)
msgid "Configure OpenStack services to use highly available Block Storage API"
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:82(para)
msgid "Your OpenStack services must now point their Block Storage API configuration to the highly available, virtual cluster IP address — rather than a Block Storage API server’s physical IP address as you normally would."
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:85(para)
msgid "You must create the Block Storage API endpoint with this IP."
msgstr ""

#: ./doc/high-availability-guide/api/section_cinder_api.xml:87(para)
msgid "If you are using both private and public IP, you should create two Virtual IPs and define your endpoint like this:"
msgstr ""

#: ./doc/high-availability-guide/api/section_api_pacemaker.xml:7(title)
msgid "Configure Pacemaker group"
msgstr ""

#: ./doc/high-availability-guide/api/section_api_pacemaker.xml:9(para)
msgid "Finally, we need to create a service <literal>group</literal> to ensure that the virtual IP is linked to the API services resources:"
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:7(title)
msgid "Highly available OpenStack Image API"
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:9(para)
msgid "OpenStack Image Service offers a service for discovering, registering, and retrieving virtual machine images. To make the OpenStack Image API service highly available in active / passive mode, you must:"
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:13(para)
msgid "Configure OpenStack Image to listen on the VIP address."
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:18(para)
msgid "Manage OpenStack Image API daemon with the Pacemaker cluster manager."
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:29(para)
msgid "Here is the <link href=\"http://docs.openstack.org/trunk/install-guide/install/apt/content/ch_glance.html\">documentation</link> for installing the OpenStack Image API service."
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:33(title)
msgid "Add OpenStack Image API resource to Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:39(para)
msgid "You can now add the Pacemaker configuration for OpenStack Image API resource. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:48(para)
msgid "<literal>p_glance-api</literal>, a resource for managing OpenStack Image API service"
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:52(para)
msgid "<literal>crm configure</literal> supports batch input, so you may copy and paste the above into your live Pacemaker configuration, and then make changes as required. For example, you may enter <literal>edit p_ip_glance-api</literal> from the <literal>crm configure</literal> menu and edit the resource to match your preferred virtual IP address."
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:57(para)
msgid "Once completed, commit your configuration changes by entering <literal>commit</literal> from the <literal>crm configure</literal> menu. Pacemaker will then start the OpenStack Image API service, and its dependent resources, on one of your nodes."
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:63(title)
msgid "Configure OpenStack Image Service API"
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:65(para)
msgid "Edit <filename>/etc/glance/glance-api.conf</filename>:"
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:81(title)
msgid "Configure OpenStack services to use high available OpenStack Image API"
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:83(para)
msgid "Your OpenStack services must now point their OpenStack Image API configuration to the highly available, virtual cluster IP address — rather than an OpenStack Image API server’s physical IP address as you normally would."
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:86(para)
msgid "For OpenStack Compute, for example, if your OpenStack Image API service IP address is 192.168.42.103 as in the configuration explained here, you would use the following configuration in your <filename>nova.conf</filename> file:"
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:96(para)
msgid "In versions prior to Juno, this option was called <literal>glance_api_servers</literal> in the <literal>[DEFAULT]</literal> section."
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:101(para)
msgid "You must also create the OpenStack Image API endpoint with this IP."
msgstr ""

#: ./doc/high-availability-guide/api/section_glance_api.xml:104(para) ./doc/high-availability-guide/api/section_neutron_server.xml:86(para)
msgid "If you are using both private and public IP addresses, you should create two Virtual IP addresses and define your endpoint like this:"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:7(title)
msgid "Highly available OpenStack Networking server"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:9(para)
msgid "OpenStack Networking is the network connectivity service in OpenStack. Making the OpenStack Networking Server service highly available in active / passive mode involves the following tasks:"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:13(para)
msgid "Configure OpenStack Networking to listen on the virtual IP address,"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:18(para)
msgid "Manage the OpenStack Networking API Server daemon with the Pacemaker cluster manager,"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:23(para)
msgid "Configure OpenStack services to use the virtual IP address."
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:29(para)
msgid "Here is the <link href=\"http://docs.openstack.org/trunk/install-guide/install/apt/content/ch_networking.html\">documentation</link> for installing OpenStack Networking service."
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:33(title)
msgid "Add OpenStack Networking Server resource to Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:39(para)
msgid "You can now add the Pacemaker configuration for OpenStack Networking Server resource. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:46(para)
msgid "This configuration creates <literal>p_neutron-server</literal>, a resource for manage OpenStack Networking Server service"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:47(para)
msgid "<literal>crm configure</literal> supports batch input, so you may copy and paste the above into your live pacemaker configuration, and then make changes as required. For example, you may enter <literal>edit p_neutron-server</literal> from the <literal>crm configure</literal> menu and edit the resource to match your preferred virtual IP address."
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:52(para)
msgid "Once completed, commit your configuration changes by entering <literal>commit</literal> from the <literal>crm configure</literal> menu. Pacemaker will then start the OpenStack Networking API service, and its dependent resources, on one of your nodes."
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:58(title)
msgid "Configure OpenStack Networking server"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:60(para)
msgid "Edit <filename>/etc/neutron/neutron.conf</filename>:"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:77(title)
msgid "Configure OpenStack services to use highly available OpenStack Networking server"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:79(para)
msgid "Your OpenStack services must now point their OpenStack Networking Server configuration to the highly available, virtual cluster IP address — rather than an OpenStack Networking server’s physical IP address as you normally would."
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:82(para)
msgid "For example, you should configure OpenStack Compute for using highly available OpenStack Networking server in editing <literal>nova.conf</literal> file:"
msgstr ""

#: ./doc/high-availability-guide/api/section_neutron_server.xml:84(para)
msgid "You need to create the OpenStack Networking server endpoint with this IP."
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:7(title)
msgid "Highly available Telemetry central agent"
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:9(para)
msgid "Telemetry (ceilometer) is the metering and monitoring service in OpenStack. The Central agent polls for resource utilization statistics for resources not tied to instances or compute nodes."
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:13(para)
msgid "Due to limitations of a polling model, a single instance of this agent can be polling a given list of meters. In this setup, we install this service on the API nodes also in the active / passive mode."
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:17(para)
msgid "Making the Telemetry central agent service highly available in active / passive mode involves managing its daemon with the Pacemaker cluster manager."
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:20(para)
msgid "You will find at <link href=\"http://docs.openstack.org/developer/ceilometer/install/manual.html#installing-the-central-agent\">this page</link> the process to install the Telemetry central agent."
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:25(title)
msgid "Add the Telemetry central agent resource to Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:31(para)
msgid "You may then proceed with adding the Pacemaker configuration for the Telemetry central agent resource. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:40(para)
msgid "<literal>p_ceilometer-agent-central</literal>, a resource for manage Ceilometer Central Agent service"
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:44(para) ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:37(para) ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:37(para)
msgid "<literal>crm configure</literal> supports batch input, so you may copy and paste the above into your live pacemaker configuration, and then make changes as required."
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:47(para)
msgid "Once completed, commit your configuration changes by entering <literal>commit</literal> from the <literal>crm configure</literal> menu. Pacemaker will then start the Ceilometer Central Agent service, and its dependent resources, on one of your nodes."
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:53(title)
msgid "Configure Telemetry central agent service"
msgstr ""

#: ./doc/high-availability-guide/api/section_ceilometer_agent_central.xml:55(para)
msgid "Edit <filename>/etc/ceilometer/ceilometer.conf</filename>:"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:7(title)
msgid "Highly available OpenStack Identity"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:9(para)
msgid "OpenStack Identity is the Identity Service in OpenStack and used by many services. Making the OpenStack Identity service highly available in active / passive mode involves"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:13(para)
msgid "Configure OpenStack Identity to listen on the VIP address,"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:18(para)
msgid "managing OpenStack Identity daemon with the Pacemaker cluster manager,"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:29(para)
msgid "Here is the <link href=\"http://docs.openstack.org/trunk/install-guide/install/apt/content/ch_keystone.html\">documentation</link> for installing OpenStack Identity service."
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:33(title)
msgid "Add OpenStack Identity resource to Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:41(para)
msgid "You can now add the Pacemaker configuration for OpenStack Identity resource. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:47(para)
msgid "This configuration creates <literal>p_keystone</literal>, a resource for managing the OpenStack Identity service."
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:48(para)
msgid "<literal>crm configure</literal> supports batch input, so you may copy and paste the above into your live pacemaker configuration, and then make changes as required. For example, you may enter <literal>edit p_ip_keystone</literal> from the <literal>crm configure</literal> menu and edit the resource to match your preferred virtual IP address."
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:53(para)
msgid "Once completed, commit your configuration changes by entering <literal>commit</literal> from the <literal>crm configure</literal> menu. Pacemaker will then start the OpenStack Identity service, and its dependent resources, on one of your nodes."
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:59(title)
msgid "Configure OpenStack Identity service"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:61(para)
msgid "You need to edit your OpenStack Identity configuration file (<filename>keystone.conf</filename>) and change the bind parameters:"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:62(para)
msgid "On Havana:"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:64(para)
msgid "On Icehouse, the <literal>admin_bind_host</literal> option lets you use a private network for the admin access."
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:67(para)
msgid "To be sure all data will be highly available, you should be sure that you store everything in the MySQL database (which is also highly available):"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:77(title)
msgid "Configure OpenStack services to use the highly available OpenStack Identity"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:79(para)
msgid "Your OpenStack services must now point their OpenStack Identity configuration to the highly available, virtual cluster IP address — rather than a OpenStack Identity server’s physical IP address as you normally would."
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:82(para)
msgid "For example with OpenStack Compute, if your OpenStack Identity service IP address is 192.168.42.103 as in the configuration explained here, you would use the following line in your API configuration file (<literal>api-paste.ini</literal>):"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:87(para)
msgid "You also need to create the OpenStack Identity Endpoint with this IP."
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:88(para)
msgid "NOTE: If you are using both private and public IP addresses, you should create two Virtual IP addresses and define your endpoint like this:"
msgstr ""

#: ./doc/high-availability-guide/api/section_keystone.xml:93(para)
msgid "If you are using the horizon dashboard, you should edit the <literal>local_settings.py</literal> file:"
msgstr ""

#: ./doc/high-availability-guide/api/section_api_vip.xml:7(title)
msgid "Configure the VIP"
msgstr ""

#: ./doc/high-availability-guide/api/section_api_vip.xml:9(para)
msgid "First, you must select and assign a virtual IP address (VIP) that can freely float between cluster nodes."
msgstr ""

#: ./doc/high-availability-guide/api/section_api_vip.xml:10(para)
msgid "This configuration creates <literal>p_ip_api</literal>, a virtual IP address for use by the API node (192.168.42.103):"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:12(title)
msgid "Highly available RabbitMQ"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:14(para)
msgid "RabbitMQ is the default AMQP server used by many OpenStack services. Making the RabbitMQ service highly available involves:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:18(para)
msgid "configuring a DRBD device for use by RabbitMQ,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:23(para)
msgid "configuring RabbitMQ to use a data directory residing on that DRBD device,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:29(para)
msgid "selecting and assigning a virtual IP address (VIP) that can freely float between cluster nodes,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:35(para)
msgid "configuring RabbitMQ to listen on that IP address,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:40(para)
msgid "managing all resources, including the RabbitMQ daemon itself, with the Pacemaker cluster manager."
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:47(para)
msgid "There is an alternative method of configuring RabbitMQ for high availability. That approach, known as <link href=\"http://www.rabbitmq.com/ha.html\">active-active mirrored queues</link>, happens to be the one preferred by the RabbitMQ developershowever it has shown less than ideal consistency and reliability in OpenStack clusters. Thus, at the time of writing, the Pacemaker/DRBD based approach remains the recommended one for OpenStack environments, although this may change in the near future as RabbitMQ active-active mirrored queues mature."
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:59(title) ./doc/high-availability-guide/controller/section_mysql.xml:56(title)
msgid "Configure DRBD"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:61(para)
msgid "The Pacemaker based RabbitMQ server requires a DRBD resource from which it mounts the <literal>/var/lib/rabbitmq</literal> directory. In this example, the DRBD resource is simply named <literal>rabbitmq</literal>:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:66(title)
msgid "<literal>rabbitmq</literal> DRBD resource configuration (<filename>/etc/drbd.d/rabbitmq.res</filename>)"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:82(para)
msgid "This resource uses an underlying local disk (in DRBD terminology, a <emphasis>backing device</emphasis>) named <literal>/dev/data/rabbitmq</literal> on both cluster nodes, <literal>node1</literal> and <literal>node2</literal>. Normally, this would be an LVM Logical Volume specifically set aside for this purpose. The DRBD <literal>meta-disk</literal> is <literal>internal</literal>, meaning DRBD-specific metadata is being stored at the end of the <literal>disk</literal> device itself. The device is configured to communicate between IPv4 addresses 10.0.42.100 and 10.0.42.254, using TCP port 7701. Once enabled, it will map to a local DRBD block device with the device minor number 1, that is, <literal>/dev/drbd1</literal>."
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:91(para) ./doc/high-availability-guide/controller/section_mysql.xml:88(para)
msgid "Enabling a DRBD resource is explained in detail in <link href=\"http://www.drbd.org/users-guide-8.3/s-first-time-up.html\">the DRBD User’s Guide</link>. In brief, the proper sequence of commands is this:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:99(para)
msgid "Initializes DRBD metadata and writes the initial set of metadata to <literal>/dev/data/rabbitmq</literal>. Must be completed on both nodes."
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:105(para)
msgid "Creates the <literal>/dev/drbd1</literal> device node, <emphasis>attaches</emphasis> the DRBD device to its backing store, and <emphasis>connects</emphasis> the DRBD node to its peer. Must be completed on both nodes."
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:112(para) ./doc/high-availability-guide/controller/section_mysql.xml:109(para)
msgid "Kicks off the initial device synchronization, and puts the device into the <literal>primary</literal> (readable and writable) role. See <link href=\"http://www.drbd.org/users-guide-8.3/ch-admin.html#s-roles\">Resource roles</link> (from the DRBD User’s Guide) for a more detailed description of the primary and secondary roles in DRBD. Must be completed <emphasis>on one node only,</emphasis> namely the one where you are about to continue with creating your filesystem."
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:126(title)
msgid "Create a file system"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:128(para)
msgid "Once the DRBD resource is running and in the primary role (and potentially still in the process of running the initial device synchronization), you may proceed with creating the filesystem for RabbitMQ data. XFS is generally the recommended filesystem:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:133(para) ./doc/high-availability-guide/controller/section_mysql.xml:130(para)
msgid "You may also use the alternate device path for the DRBD device, which may be easier to remember as it includes the self-explanatory resource name:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:137(para) ./doc/high-availability-guide/controller/section_mysql.xml:134(para)
msgid "Once completed, you may safely return the device to the secondary role. Any ongoing device synchronization will continue in the background:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:144(title)
msgid "Prepare RabbitMQ for Pacemaker high availability"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:146(para)
msgid "In order for Pacemaker monitoring to function properly, you must ensure that RabbitMQ’s <literal>.erlang.cookie</literal> files are identical on all nodes, regardless of whether DRBD is mounted there or not. The simplest way of doing so is to take an existing <literal>.erlang.cookie</literal> from one of your nodes, copying it to the RabbitMQ data directory on the other node, and also copying it to the DRBD-backed filesystem."
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:159(title)
msgid "Add RabbitMQ resources to Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:161(para)
msgid "You may now proceed with adding the Pacemaker configuration for RabbitMQ resources. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:194(para)
msgid "<literal>p_ip_rabbitmq</literal>, a virtual IP address for use by RabbitMQ (192.168.42.100),"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:199(para)
msgid "<literal>p_fs_rabbitmq</literal>, a Pacemaker managed filesystem mounted to <literal>/var/lib/rabbitmq</literal> on whatever node currently runs the RabbitMQ service,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:205(para)
msgid "<literal>ms_drbd_rabbitmq</literal>, the <emphasis>master/slave set</emphasis> managing the <literal>rabbitmq</literal> DRBD resource,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:210(para) ./doc/high-availability-guide/controller/section_mysql.xml:222(para)
msgid "a service <literal>group</literal> and <literal>order</literal> and <literal>colocation</literal> constraints to ensure resources are started on the correct nodes, and in the correct sequence."
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:216(para)
msgid "<literal>crm configure</literal> supports batch input, so you may copy and paste the above into your live pacemaker configuration, and then make changes as required. For example, you may enter <literal>edit p_ip_rabbitmq</literal> from the <literal>crm configure</literal> menu and edit the resource to match your preferred virtual IP address."
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:221(para)
msgid "Once completed, commit your configuration changes by entering <literal>commit</literal> from the <literal>crm configure</literal> menu. Pacemaker will then start the RabbitMQ service, and its dependent resources, on one of your nodes."
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:227(title)
msgid "Configure OpenStack services for highly available RabbitMQ"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:229(para)
msgid "Your OpenStack services must now point their RabbitMQ configuration to the highly available, virtual cluster IP addressrather than a RabbitMQ server"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:232(para)
msgid "For OpenStack Image, for example, if your RabbitMQ service IP address is 192.168.42.100 as in the configuration explained here, you would use the following line in your OpenStack Image API configuration file (<filename>glance-api.conf</filename>):"
msgstr ""

#: ./doc/high-availability-guide/controller/section_rabbitmq.xml:237(para)
msgid "No other changes are necessary to your OpenStack configuration. If the node currently hosting your RabbitMQ experiences a problem necessitating service failover, your OpenStack services may experience a brief RabbitMQ interruption, as they would in the event of a network hiccup, and then continue to run normally."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:12(title)
msgid "Highly available MySQL"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:14(para)
msgid "MySQL is the default database server used by many OpenStack services. Making the MySQL service highly available involves"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:18(para)
msgid "Configure a DRBD device for use by MySQL,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:23(para)
msgid "Configure MySQL to use a data directory residing on that DRBD device,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:29(para)
msgid "Select and assign a virtual IP address (VIP) that can freely float between cluster nodes,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:35(para)
msgid "Configure MySQL to listen on that IP address,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:40(para)
msgid "Manage all resources, including the MySQL daemon itself, with the Pacemaker cluster manager."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:47(para)
msgid "<link href=\"http://galeracluster.com/\">MySQL/Galera</link> is an alternative method of configuring MySQL for high availability. It is likely to become the preferred method of achieving MySQL high availability once it has sufficiently matured. At the time of writing, however, the Pacemaker/DRBD based approach remains the recommended one for OpenStack environments."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:58(para)
msgid "The Pacemaker based MySQL server requires a DRBD resource from which it mounts the <literal>/var/lib/mysql</literal> directory. In this example, the DRBD resource is simply named <literal>mysql</literal>:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:63(title)
msgid "<literal>mysql</literal> DRBD resource configuration (<filename>/etc/drbd.d/mysql.res</filename>)"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:79(para)
msgid "This resource uses an underlying local disk (in DRBD terminology, a <emphasis>backing device</emphasis>) named <literal>/dev/data/mysql</literal> on both cluster nodes, <literal>node1</literal> and <literal>node2</literal>. Normally, this would be an LVM Logical Volume specifically set aside for this purpose. The DRBD <literal>meta-disk</literal> is <literal>internal</literal>, meaning DRBD-specific metadata is being stored at the end of the <literal>disk</literal> device itself. The device is configured to communicate between IPv4 addresses 10.0.42.100 and 10.0.42.254, using TCP port 7700. Once enabled, it will map to a local DRBD block device with the device minor number 0, that is, <filename>/dev/drbd0</filename>."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:96(para)
msgid "Initializes DRBD metadata and writes the initial set of metadata to <literal>/dev/data/mysql</literal>. Must be completed on both nodes."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:102(para)
msgid "Creates the <literal>/dev/drbd0</literal> device node, <emphasis>attaches</emphasis> the DRBD device to its backing store, and <emphasis>connects</emphasis> the DRBD node to its peer. Must be completed on both nodes."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:123(title)
msgid "Creating a file system"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:125(para)
msgid "Once the DRBD resource is running and in the primary role (and potentially still in the process of running the initial device synchronization), you may proceed with creating the filesystem for MySQL data. XFS is the generally recommended filesystem due to its journaling, efficient allocation, and performance:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:141(title)
msgid "Prepare MySQL for Pacemaker high availability"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:143(para)
msgid "In order for Pacemaker monitoring to function properly, you must ensure that MySQL’s database files reside on the DRBD device. If you already have an existing MySQL database, the simplest approach is to just move the contents of the existing <literal>/var/lib/mysql</literal> directory into the newly created filesystem on the DRBD device."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:149(para)
msgid "You must complete the next step while the MySQL database server is shut down."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:155(para)
msgid "For a new MySQL installation with no existing data, you may also run the <literal>mysql_install_db</literal> command:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:160(para)
msgid "Regardless of the approach, the steps outlined here must be completed on only one cluster node."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:165(title)
msgid "Add MySQL resources to Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:167(para)
msgid "You can now add the Pacemaker configuration for MySQL resources. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:206(para)
msgid "<literal>p_ip_mysql</literal>, a virtual IP address for use by MySQL (192.168.42.101),"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:211(para)
msgid "<literal>p_fs_mysql</literal>, a Pacemaker managed filesystem mounted to <literal>/var/lib/mysql</literal> on whatever node currently runs the MySQL service,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:217(para)
msgid "<literal>ms_drbd_mysql</literal>, the <emphasis>master/slave set</emphasis> managing the <literal>mysql</literal> DRBD resource,"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:228(para)
msgid "<literal>crm configure</literal> supports batch input, so you may copy and paste the above into your live pacemaker configuration, and then make changes as required. For example, you may enter <literal>edit p_ip_mysql</literal> from the <literal>crm configure</literal> menu and edit the resource to match your preferred virtual IP address."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:233(para)
msgid "Once completed, commit your configuration changes by entering <literal>commit</literal> from the <literal>crm configure</literal> menu. Pacemaker will then start the MySQL service, and its dependent resources, on one of your nodes."
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:239(title)
msgid "Configure OpenStack services for highly available MySQL"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:241(para)
msgid "Your OpenStack services must now point their MySQL configuration to the highly available, virtual cluster IP addressrather than a MySQL server"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:244(para)
msgid "For OpenStack Image, for example, if your MySQL service IP address is 192.168.42.101 as in the configuration explained here, you would use the following line in your OpenStack Image registry configuration file (<filename>glance-registry.conf</filename>):"
msgstr ""

#: ./doc/high-availability-guide/controller/section_mysql.xml:249(para)
msgid "No other changes are necessary to your OpenStack configuration. If the node currently hosting your database experiences a problem necessitating service failover, your OpenStack services may experience a brief MySQL interruption, as they would in the event of a network hiccup, and then continue to run normally."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_memcached.xml:7(title)
msgid "Memcached"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_memcached.xml:9(para)
msgid "Most OpenStack services use an application to offer persistence and store ephemeral data (like tokens). Memcached is one of them and can scale-out easily without any specific tricks required."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_memcached.xml:11(para)
msgid "To install and configure it, read the <link href=\"http://code.google.com/p/memcached/wiki/NewStart\">official documentation</link>."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_memcached.xml:12(para)
msgid "Memory caching is managed by oslo-incubator, so the way to use multiple memcached servers is the same for all projects."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_memcached.xml:13(para)
msgid "Example with two hosts:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_memcached.xml:15(para)
msgid "By default, controller1 handles the caching service but if the host goes down, controller2 does the job. For more information about memcached installation, see the OpenStack Cloud Administrator Guide."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:7(title)
msgid "Run OpenStack API and schedulers"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:11(title)
msgid "API services"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:13(para)
msgid "All OpenStack projects have an API service for controlling all the resources in the Cloud. In Active / Active mode, the most common setup is to scale-out these services on at least two nodes and use load balancing and virtual IP (with HAProxy &amp; Keepalived in this setup)."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:17(emphasis)
msgid "Configure API OpenStack services"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:19(para)
msgid "To configure our Cloud using Highly available and scalable API services, we need to ensure that:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:22(para)
msgid "You use virtual IPs when configuring OpenStack Identity endpoints."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:27(para)
msgid "All OpenStack configuration files should refer to virtual IPs."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:33(emphasis)
msgid "In case of failure"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:35(para)
msgid "The monitor check is quite simple since it just establishes a TCP connection to the API port. Comparing to the Active / Passive mode using Corosync &amp; Resources Agents, we don’t check if the service is actually running). That’s why all OpenStack API should be monitored by another tool, for example Nagios, with the goal to detect failures in the Cloud Framework infrastructure."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:42(title)
msgid "Schedulers"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:44(para)
msgid "OpenStack schedulers are used to determine how to dispatch compute, network and volume requests. The most common setup is to use RabbitMQ as messaging system already documented in this guide. Those services are connected to the messaging backend and can scale-out:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:49(para)
msgid "nova-scheduler"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:54(para)
msgid "nova-conductor"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:59(para)
msgid "cinder-scheduler"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:64(para)
msgid "neutron-server"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:69(para)
msgid "ceilometer-collector"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:74(para)
msgid "heat-engine"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_controllers/section_run_openstack_api_and_schedulers.xml:79(para)
msgid "Please refer to the RabbitMQ section for configure these services with multiple messaging servers."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_start_pacemaker.xml:6(title)
msgid "Start Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_start_pacemaker.xml:7(para)
msgid "Once the Corosync services have been started and you have established that the cluster is communicating properly, it is safe to start <literal>pacemakerd</literal>, the Pacemaker master control process:"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_start_pacemaker.xml:12(para)
msgid "<literal>/etc/init.d/pacemaker start</literal> (LSB)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_start_pacemaker.xml:16(para)
msgid "<literal>service pacemaker start</literal> (LSB, alternate)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_start_pacemaker.xml:20(para)
msgid "<literal>start pacemaker</literal> (upstart)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_start_pacemaker.xml:24(para)
msgid "<literal>systemctl start pacemaker</literal> (systemd)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_start_pacemaker.xml:28(para)
msgid "Once Pacemaker services have started, Pacemaker will create a default empty cluster configuration with no resources. You may observe Pacemaker’s status with the <literal>crm_mon</literal> utility:"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:6(title)
msgid "Set up Corosync"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:7(para)
msgid "Besides installing the <literal>corosync</literal> package, you must also create a configuration file, stored in <filename>/etc/corosync/corosync.conf</filename>. Most distributions ship an example configuration file (<filename>corosync.conf.example</filename>) as part of the documentation bundled with the <literal>corosync</literal> package. An example Corosync configuration file is shown below:"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:15(title)
msgid "Corosync configuration file (<filename>corosync.conf</filename>)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:89(para)
msgid "The <literal>token</literal> value specifies the time, in milliseconds, during which the Corosync token is expected to be transmitted around the ring. When this timeout expires, the token is declared lost, and after <literal>token_retransmits_before_loss_const</literal> lost tokens the non-responding <emphasis>processor</emphasis> (cluster node) is declared dead. In other words, <literal>token</literal> × <literal>token_retransmits_before_loss_const</literal> is the maximum time a node is allowed to not respond to cluster messages before being considered dead. The default for <literal>token</literal> is 1000 (1 second), with 4 allowed retransmits. These defaults are intended to minimize failover times, but can cause frequent \"false alarms\" and unintended failovers in case of short network interruptions. The values used here are safer, albeit with slightly extended failover times."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:105(para)
msgid "With <literal>secauth</literal> enabled, Corosync nodes mutually authenticate using a 128-byte shared secret stored in <literal>/etc/corosync/authkey</literal>, which may be generated with the <literal>corosync-keygen</literal> utility. When using <literal>secauth</literal>, cluster communications are also encrypted."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:113(para)
msgid "In Corosync configurations using redundant networking (with more than one <literal>interface</literal>), you must select a Redundant Ring Protocol (RRP) mode other than <literal>none</literal>. <literal>active</literal> is the recommended RRP mode."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:120(para)
msgid "There are several things to note about the recommended interface configuration:"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:126(para)
msgid "The <literal>ringnumber</literal> must differ between all configured interfaces, starting with 0."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:132(para)
msgid "The <literal>bindnetaddr</literal> is the <emphasis>network</emphasis> address of the interfaces to bind to. The example uses two network addresses of <literal>/24</literal> IPv4 subnets."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:138(para)
msgid "Multicast groups (<literal>mcastaddr</literal>) <emphasis>must not</emphasis> be reused across cluster boundaries. In other words, no two distinct clusters should ever use the same multicast group. Be sure to select multicast addresses compliant with <link href=\"http://www.ietf.org/rfc/rfc2365.txt\">RFC 2365, \"Administratively Scoped IP Multicast\"</link>."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:147(para)
msgid "For firewall configurations, note that Corosync communicates over UDP only, and uses <literal>mcastport</literal> (for receives) and <literal>mcastport</literal>-1 (for sends)."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:156(para)
msgid "The <literal>service</literal> declaration for the <literal>pacemaker</literal> service may be placed in the <filename>corosync.conf</filename> file directly, or in its own separate file, <filename>/etc/corosync/service.d/pacemaker</filename>."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_up_corosync.xml:163(para)
msgid "Once created, the <filename>corosync.conf</filename> file (and the <filename>authkey</filename> file if the <literal>secauth</literal> option is enabled) must be synchronized across all cluster nodes."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_install_packages.xml:6(title)
msgid "Install packages"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_install_packages.xml:7(para)
msgid "On any host that is meant to be part of a Pacemaker cluster, you must first establish cluster communications through the Corosync messaging layer. This involves installing the following packages (and their dependencies, which your package manager will normally install automatically):"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_install_packages.xml:14(para)
msgid "<literal>pacemaker</literal> (Note that the crm shell should be downloaded separately.)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_install_packages.xml:19(literal)
msgid "crmsh"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_install_packages.xml:24(literal)
msgid "corosync"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_install_packages.xml:29(literal)
msgid "cluster-glue"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_install_packages.xml:33(para)
msgid "<literal>fence-agents</literal> (Fedora only; all other distributions use fencing agents from <literal>cluster-glue</literal>)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_install_packages.xml:39(literal)
msgid "resource-agents"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_basic_cluster_properties.xml:7(title)
msgid "Set basic cluster properties"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_basic_cluster_properties.xml:9(para)
msgid "Once your Pacemaker cluster is set up, it is recommended to set a few basic cluster properties. To do so, start the <literal>crm</literal> shell and change into the configuration menu by entering <literal>configure</literal>. Alternatively, you may jump straight into the Pacemaker configuration menu by typing <literal>crm configure</literal> directly from a shell prompt."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_basic_cluster_properties.xml:15(para)
msgid "Then, set the following properties:"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_basic_cluster_properties.xml:23(para)
msgid "Setting <literal>no-quorum-policy=\"ignore\"</literal> is required in 2-node Pacemaker clusters for the following reason: if quorum enforcement is enabled, and one of the two nodes fails, then the remaining node can not establish a <emphasis>majority</emphasis> of quorum votes necessary to run services, and thus it is unable to take over any resources. In this case, the appropriate workaround is to ignore loss of quorum in the cluster. This should only <emphasis>only</emphasis> be done in 2-node clusters: do not set this property in Pacemaker clusters with more than two nodes. Note that a two-node cluster with this setting exposes a risk of split-brain because either half of the cluster, or both, are able to become active in the event that both nodes remain online but lose communication with one another. The preferred configuration is 3 or more nodes per cluster."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_basic_cluster_properties.xml:34(para)
msgid "Setting <literal>pe-warn-series-max</literal>, <literal>pe-input-series-max</literal> and <literal>pe-error-series-max</literal> to 1000 instructs Pacemaker to keep a longer history of the inputs processed, and errors and warnings generated, by its Policy Engine. This history is typically useful in case cluster troubleshooting becomes necessary."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_basic_cluster_properties.xml:43(para)
msgid "Pacemaker uses an event-driven approach to cluster state processing. However, certain Pacemaker actions occur at a configurable interval, <literal>cluster-recheck-interval</literal>, which defaults to 15 minutes. It is usually prudent to reduce this to a shorter interval, such as 5 or 3 minutes."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_set_basic_cluster_properties.xml:52(para)
msgid "Once you have made these changes, you may <literal>commit</literal> the updated configuration."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_starting_corosync.xml:7(title)
msgid "Starting Corosync"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_starting_corosync.xml:9(para)
msgid "Corosync is started as a regular system service. Depending on your distribution, it may ship with an LSB init script, an upstart job, or a systemd unit file. Either way, the service is usually named <literal>corosync</literal>:"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_starting_corosync.xml:15(para)
msgid "<literal>/etc/init.d/corosync start</literal> (LSB)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_starting_corosync.xml:19(para)
msgid "<literal>service corosync start</literal> (LSB, alternate)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_starting_corosync.xml:23(para)
msgid "<literal>start corosync</literal> (upstart)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_starting_corosync.xml:27(para)
msgid "<literal>systemctl start corosync</literal> (systemd)"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_starting_corosync.xml:31(para)
msgid "You can now check the Corosync connectivity with two tools."
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_starting_corosync.xml:32(para)
msgid "The <literal>corosync-cfgtool</literal> utility, when invoked with the <literal>-s</literal> option, gives a summary of the health of the communication rings:"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_starting_corosync.xml:43(para)
msgid "The <literal>corosync-objctl</literal> utility can be used to dump the Corosync cluster member list:"
msgstr ""

#: ./doc/high-availability-guide/pacemaker/section_starting_corosync.xml:52(para)
msgid "You should see a <literal>status=joined</literal> entry for each of your constituent cluster nodes."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:7(title)
msgid "Configure OpenStack services to use RabbitMQ"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:9(para)
msgid "We have to configure the OpenStack components to use at least two RabbitMQ nodes."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:10(para)
msgid "Do this configuration on all services using RabbitMQ:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:11(para)
msgid "RabbitMQ HA cluster host:port pairs:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:13(para)
msgid "How frequently to retry connecting with RabbitMQ:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:15(para)
msgid "How long to back-off for between retries when connecting to RabbitMQ:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:17(para)
msgid "Maximum retries with trying to connect to RabbitMQ (infinite by default):"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:19(para)
msgid "Use durable queues in RabbitMQ:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:21(para)
msgid "Use HA queues in RabbitMQ (x-ha-policy: all):"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:23(para)
msgid "If you change the configuration from an old setup which did not use HA queues, you should interrupt the service:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_openstack_services_to_user_rabbitmq.xml:27(para)
msgid "Services currently working with HA queues: OpenStack Compute, OpenStack Block Storage, OpenStack Networking, Telemetry."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_install_rabbitmq.xml:9(para)
msgid "This setup has been tested with RabbitMQ 2.7.1."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_install_rabbitmq.xml:12(title)
msgid "On Ubuntu / Debian"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_install_rabbitmq.xml:14(para) ./doc/high-availability-guide/ha_aa_rabbitmq/section_install_rabbitmq.xml:24(para)
msgid "RabbitMQ is packaged on both distros:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_install_rabbitmq.xml:17(link)
msgid "Official manual for installing RabbitMQ on Ubuntu / Debian"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_install_rabbitmq.xml:22(title)
msgid "On Fedora / RHEL"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_install_rabbitmq.xml:27(link)
msgid "Official manual for installing RabbitMQ on Fedora / RHEL"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_rabbitmq.xml:7(title)
msgid "Configure RabbitMQ"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_rabbitmq.xml:9(para)
msgid "Here we are building a cluster of RabbitMQ nodes to construct a RabbitMQ broker. Mirrored queues in RabbitMQ improve the availability of service since it will be resilient to failures. We have to consider that while exchanges and bindings will survive the loss of individual nodes, queues and their messages will not because a queue and its contents is located on one node. If we lose this node, we also lose the queue."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_rabbitmq.xml:14(para)
msgid "We consider that we run (at least) two RabbitMQ servers. To build a broker, we need to ensure that all nodes have the same Erlang cookie file. To do so, stop RabbitMQ everywhere and copy the cookie from rabbit1 server to other server(s):"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_rabbitmq.xml:19(para)
msgid "Then, start RabbitMQ on nodes. If RabbitMQ fails to start, you can’t continue to the next step."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_rabbitmq.xml:21(para)
msgid "Now, we are building the HA cluster. From rabbit2, run these commands:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_rabbitmq.xml:25(para)
msgid "To verify the cluster status:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_rabbitmq.xml:31(para)
msgid "If the cluster is working, you can now proceed to creating users and passwords for queues."
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_rabbitmq.xml:33(emphasis)
msgid "Note for RabbitMQ version 3"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_rabbitmq.xml:35(para)
msgid "Queue mirroring is no longer controlled by the <emphasis>x-ha-policy</emphasis> argument when declaring a queue. OpenStack can continue to declare this argument, but it won’t cause queues to be mirrored. We need to make sure that all queues (except those with auto-generated names) are mirrored across all running nodes:"
msgstr ""

#: ./doc/high-availability-guide/ha_aa_rabbitmq/section_configure_rabbitmq.xml:40(link)
msgid "More information about High availability in RabbitMQ"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_metadata_agent.xml:6(title)
msgid "Highly available neutron metadata agent"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_metadata_agent.xml:7(para)
msgid "Neutron metadata agent allows Compute API metadata to be reachable by VMs on tenant networks. High availability for the metadata agent is achieved by adopting Pacemaker."
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_metadata_agent.xml:11(para)
msgid "Here is the <link href=\"http://docs.openstack.org/trunk/config-reference/content/networking-options-metadata.html\">documentation</link> for installing Neutron Metadata Agent."
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_metadata_agent.xml:14(title)
msgid "Add neutron metadata agent resource to Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_metadata_agent.xml:19(para)
msgid "You may now proceed with adding the Pacemaker configuration for neutron metadata agent resource. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_metadata_agent.xml:29(para)
msgid "<literal>p_neutron-metadata-agent</literal>, a resource for manage Neutron Metadata Agent service"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_metadata_agent.xml:34(para)
msgid "<literal>crm configure</literal> supports batch input, so you may copy and paste the above into your live Pacemaker configuration, and then make changes as required."
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_metadata_agent.xml:37(para)
msgid "Once completed, commit your configuration changes by entering <literal>commit</literal> from the <literal>crm configure</literal> menu. Pacemaker will then start the neutron metadata agent service, and its dependent resources, on one of your nodes."
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:7(title)
msgid "Highly available neutron L3 agent"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:9(para)
msgid "The neutron L3 agent provides L3/NAT forwarding to ensure external network access for VMs on tenant networks. High availability for the L3 agent is achieved by adopting Pacemaker."
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:13(para)
msgid "Here is the <link href=\"http://docs.openstack.org/trunk/config-reference/content/section_adv_cfg_l3_agent.html\">documentation</link> for installing neutron L3 agent."
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:17(title)
msgid "Add neutron L3 agent resource to Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:23(para)
msgid "You may now proceed with adding the Pacemaker configuration for neutron L3 agent resource. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:33(para)
msgid "<literal>p_neutron-l3-agent</literal>, a resource for manage Neutron L3 Agent service"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:40(para)
msgid "Once completed, commit your configuration changes by entering <literal>commit</literal> from the <literal>crm configure</literal> menu. Pacemaker will then start the neutron L3 agent service, and its dependent resources, on one of your nodes."
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_l3_agent.xml:44(para)
msgid "This method does not ensure a zero downtime since it has to recreate all the namespaces and virtual routers on the node."
msgstr ""

#: ./doc/high-availability-guide/network/section_manage_network_resources.xml:7(title)
msgid "Manage network resources"
msgstr ""

#: ./doc/high-availability-guide/network/section_manage_network_resources.xml:9(para)
msgid "You can now add the Pacemaker configuration for managing all network resources together with a group. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:7(title)
msgid "Highly available neutron DHCP agent"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:9(para)
msgid "Neutron DHCP agent distributes IP addresses to the VMs with dnsmasq (by default). High availability for the DHCP agent is achieved by adopting Pacemaker."
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:13(para)
msgid "Here is the <link href=\"http://docs.openstack.org/trunk/config-reference/content/section_adv_cfg_dhcp_agent.html\">documentation</link> for installing neutron DHCP agent."
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:17(title)
msgid "Add neutron DHCP agent resource to Pacemaker"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:23(para)
msgid "You may now proceed with adding the Pacemaker configuration for neutron DHCP agent resource. Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following cluster resources:"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:30(para)
msgid "This configuration creates:"
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:33(para)
msgid "<literal>p_neutron-agent-dhcp</literal>, a resource for manage Neutron DHCP Agent service."
msgstr ""

#: ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:40(para)
msgid "Once completed, commit your configuration changes by entering <literal>commit</literal> from the <literal>crm configure</literal> menu. Pacemaker will then start the neutron DHCP agent service, and its dependent resources, on one of your nodes."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: ./doc/high-availability-guide/network/section_highly_available_neutron_dhcp_agent.xml:0(None)
msgid "translator-credits"
msgstr ""

