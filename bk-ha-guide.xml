<?xml version="1.0" encoding="utf-8"?>
<book xml:id="bk-ha-guide" xmlns="http://docbook.org/ns/docbook" version="lillet" xml:lang="en">
  <info>
    <title>OpenStack High Availability Guide</title>
    <author>
      <personname>
        <firstname>Florian</firstname>
        <surname>Haas</surname>
      </personname>
      <email>florian@hastexo.com</email>
      <affiliation>
        <orgname>hastexo</orgname>
      </affiliation>
    </author>
    <copyright>
      <year>2012</year>
      <year>2013</year>
      <holder>OpenStack Contributors</holder>
    </copyright>
    <releaseinfo>current</releaseinfo>
    <productname>OpenStack</productname>
    <pubdate/>
    <legalnotice role="apache2">
      <annotation>
        <remark>Copyright details are filled in by the template.</remark>
      </annotation>
    </legalnotice>
    <abstract>
      <para>This guide describes how to install,
            configure, and manage OpenStack for high availability.</para>
    </abstract>
    <revhistory>
      <revision>
        <date>2014-04-17</date>
        <revdescription>
          <itemizedlist spacing="compact">
            <listitem>
              <para>Minor cleanup of typos, otherwise no
                            major revisions for Icehouse release.</para>
            </listitem>
          </itemizedlist>
        </revdescription>
      </revision>
      <revision>
        <date>2012-01-16</date>
        <revdescription>
          <itemizedlist spacing="compact">
            <listitem>
              <para>Organizes guide based on cloud controller and compute nodes.</para>
            </listitem>
          </itemizedlist>
        </revdescription>
      </revision>
      <revision>
        <date>2012-05-24</date>
        <revdescription>
          <itemizedlist spacing="compact">
            <listitem>
              <para>Begin trunk designation.</para>
            </listitem>
          </itemizedlist>
        </revdescription>
      </revision>
    </revhistory>
  </info>
  <chapter xml:id="ch-intro">
    <info>
      <title>Introduction to OpenStack High Availability</title>
    </info>
    <simpara>High Availability systems seek to minimize two things:</simpara>
    <itemizedlist>
      <listitem>
        <simpara><emphasis role="strong">System downtime</emphasis> — occurs when a <emphasis>user-facing</emphasis> service is unavailable beyond a specified maximum amount of time, and
</simpara>
      </listitem>
      <listitem>
        <simpara><emphasis role="strong">Data loss</emphasis> — accidental deletion or destruction of data.
</simpara>
      </listitem>
    </itemizedlist>
    <simpara>Most high availability systems guarantee protection against system downtime and data loss only in the event of a single failure. However, they are also expected to protect against cascading failures, where a single failure deteriorates into a series of consequential failures.</simpara>
    <simpara>A crucial aspect of high availability is the elimination of single points of failure (SPOFs). A SPOF is an individual piece of equipment or software which will cause system downtime or data loss if it fails. In order to eliminate SPOFs, check that mechanisms exist for redundancy of:</simpara>
    <itemizedlist>
      <listitem>
        <simpara>
Network components, such as switches and routers
</simpara>
      </listitem>
      <listitem>
        <simpara>
Applications and automatic service migration
</simpara>
      </listitem>
      <listitem>
        <simpara>
Storage components
</simpara>
      </listitem>
      <listitem>
        <simpara>
Facility services such as power, air conditioning, and fire protection
</simpara>
      </listitem>
    </itemizedlist>
    <simpara>Most high availability systems will fail in the event of multiple independent (non-consequential) failures. In this case, most systems will protect data over maintaining availability.</simpara>
    <simpara>High-availability systems typically achieve uptime of 99.99% or more, which roughly equates to less than an hour of cumulative downtime per year. In order to achieve this, high availability systems should keep recovery times after a failure to about one to two minutes, sometimes significantly less.</simpara>
    <simpara>OpenStack currently meets such availability requirements for its own infrastructure services, meaning that an uptime of 99.99% is feasible for the OpenStack infrastructure proper. However, OpenStack <emphasis>does</emphasis> <emphasis>not</emphasis> guarantee 99.99% availability for individual guest instances.</simpara>
    <simpara>Preventing single points of failure can depend on whether or not a service is stateless.</simpara>
    <section xml:id="stateless-vs-stateful">
      <info>
        <title>Stateless vs. Stateful services</title>
      </info>
      <simpara>A stateless service is one that provides a response after your request, and then requires no further attention. To make a stateless service highly available, you need to provide redundant instances and load balance them. OpenStack services that are stateless include nova-api, nova-conductor, glance-api, keystone-api, neutron-api and nova-scheduler.</simpara>
      <simpara>A stateful service is one where subsequent requests to the service depend on the results of the first request. Stateful services are more difficult to manage because a single action typically involves more than one request, so simply providing additional instances and load balancing will not solve the problem. For example, if the Horizon user interface reset itself every time you went to a new page, it wouldn’t be very useful. OpenStack services that are stateful include the OpenStack database and message queue.</simpara>
      <simpara>Making stateful services highly available can depend on whether you choose an active/passive or active/active configuration.</simpara>
    </section>
    <section xml:id="ap-intro">
      <info>
        <title>Active/Passive</title>
      </info>
      <simpara>In an active/passive configuration, systems are set up to bring additional resources online to replace those that have failed. For example, OpenStack would write to the main database while maintaining a disaster recovery database that can be brought online in the event that the main database fails.</simpara>
      <simpara>Typically, an active/passive installation for a stateless service would maintain a redundant instance that can be brought online when required. Requests are load balanced using a virtual IP address and a load balancer such as HAProxy.</simpara>
      <simpara>A typical active/passive installation for a stateful service maintains a replacement resource that can be brought online when required. A separate application (such as Pacemaker or Corosync) monitors these services, bringing the backup online as necessary.</simpara>
    </section>
    <section xml:id="aa-intro">
      <info>
        <title>Active/Active</title>
      </info>
      <simpara>In an active/active configuration, systems also use a backup but will manage both the main and redundant systems concurrently. This way, if there is a failure the user is unlikely to notice. The backup system is already online, and takes on increased load while the main system is fixed and brought back online.</simpara>
      <simpara>Typically, an active/active installation for a stateless service would maintain a redundant instance, and requests are load balanced using a virtual IP address and a load balancer such as HAProxy.</simpara>
      <simpara>A typical active/active installation for a stateful service would include redundant services with all instances having an identical state. For example, updates to one instance of a database would also update all other instances. This way a request to one instance is the same as a request to any other. A load balancer manages the traffic to these systems, ensuring that operational systems always handle the request.</simpara>
      <simpara>These are some of the more common ways to implement these high availability architectures, but they are by no means the only ways to do it. The important thing is to make sure that your services are redundant, and available; how you achieve that is up to you. This document will cover some of the more common options for highly available systems.</simpara>
    </section>
  </chapter>
  <chapter xml:id="ha-using-active-passive">
    <info>
      <title>HA using active/passive</title>
    </info>
    <section xml:id="ch-pacemaker">
      <info>
        <title>The Pacemaker cluster stack</title>
      </info>
      <simpara>OpenStack infrastructure high availability relies on the
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.clusterlabs.org">Pacemaker</link> cluster stack, the
state-of-the-art high availability and load balancing stack for the
Linux platform. Pacemaker is storage and application-agnostic, and is
in no way specific to OpenStack.</simpara>
      <simpara>Pacemaker relies on the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.corosync.org">Corosync</link> messaging
layer for reliable cluster communications. Corosync implements the
Totem single-ring ordering and membership protocol. It also provides UDP
and InfiniBand based messaging, quorum, and cluster membership to
Pacemaker.</simpara>
      <simpara>Pacemaker interacts with applications through <emphasis>resource agents</emphasis> (RAs),
of which it supports over 70 natively. Pacemaker can also easily use
third-party RAs. An OpenStack high-availability configuration uses
existing native Pacemaker RAs (such as those managing MySQL
databases or virtual IP addresses), existing third-party RAs (such as
for RabbitMQ), and native OpenStack RAs (such as those managing the
OpenStack Identity and Image Services).</simpara>
      <section xml:id="_install_packages">
        <info>
          <title>Install packages</title>
        </info>
        <simpara>On any host that is meant to be part of a Pacemaker cluster, you must
first establish cluster communications through the Corosync messaging
layer. This involves Install the following packages (and their
dependencies, which your package manager will normally install
automatically):</simpara>
        <itemizedlist>
          <listitem>
            <simpara><literal>pacemaker</literal> Note that the crm shell should be downloaded separately.
</simpara>
          </listitem>
          <listitem>
            <simpara>
              <literal>crmsh</literal>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <literal>corosync</literal>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <literal>cluster-glue</literal>
            </simpara>
          </listitem>
          <listitem>
            <simpara><literal>fence-agents</literal> (Fedora only; all other distributions use fencing
  agents from <literal>cluster-glue</literal>)
</simpara>
          </listitem>
          <listitem>
            <simpara>
              <literal>resource-agents</literal>
            </simpara>
          </listitem>
        </itemizedlist>
      </section>
      <section xml:id="_set_up_corosync">
        <info>
          <title>Set up Corosync</title>
        </info>
        <simpara>Besides installing the <literal>corosync</literal> package, you must also
create a configuration file, stored in
<literal>/etc/corosync/corosync.conf</literal>. Most distributions ship an example
configuration file (<literal>corosync.conf.example</literal>) as part of the
documentation bundled with the <literal>corosync</literal> package. An example Corosync
configuration file is shown below:</simpara>
        <formalpara>
          <info>
            <title>Corosync configuration file (<literal>corosync.conf</literal>)</title>
          </info>
          <para>
            <screen>totem {
        version: 2

        # Time (in ms) to wait for a token <co xml:id="CO1-1"/>
        token: 10000

        # How many token retransmits before forming a new
        # configuration
        token_retransmits_before_loss_const: 10

        # Turn off the virtual synchrony filter
        vsftype: none

        # Enable encryption <co xml:id="CO1-2"/>
        secauth: on

        # How many threads to use for encryption/decryption
        threads: 0

        # This specifies the redundant ring protocol, which may be
        # none, active, or passive. <co xml:id="CO1-3"/>
        rrp_mode: active

        # The following is a two-ring multicast configuration. <co xml:id="CO1-4"/>
        interface {
                ringnumber: 0
                bindnetaddr: 192.168.42.0
                mcastaddr: 239.255.42.1
                mcastport: 5405
        }
        interface {
                ringnumber: 1
                bindnetaddr: 10.0.42.0
                mcastaddr: 239.255.42.2
                mcastport: 5405
        }
}

amf {
        mode: disabled
}

service {
        # Load the Pacemaker Cluster Resource Manager <co xml:id="CO1-5"/>
        ver:       1
        name:      pacemaker
}

aisexec {
        user:   root
        group:  root
}

logging {
        fileline: off
        to_stderr: yes
        to_logfile: no
        to_syslog: yes
        syslog_facility: daemon
        debug: off
        timestamp: on
        logger_subsys {
                subsys: AMF
                debug: off
                tags: enter|leave|trace1|trace2|trace3|trace4|trace6
        }
}</screen>
          </para>
        </formalpara>
        <calloutlist>
          <callout arearefs="CO1-1">
            <para>
The <literal>token</literal> value specifies the time, in milliseconds, during
which the Corosync token is expected to be transmitted around the
ring. When this timeout expires, the token is declared lost, and after
<literal>token_retransmits_before_loss_const</literal> lost tokens the non-responding
<emphasis>processor</emphasis> (cluster node) is declared dead. In other words,
<literal>token</literal> × <literal>token_retransmits_before_loss_const</literal> is the maximum
time a node is allowed to not respond to cluster messages before being
considered dead. The default for <literal>token</literal> is 1000 (1 second), with 4
allowed retransmits. These defaults are intended to minimize failover
times, but can cause frequent "false alarms" and unintended failovers
in case of short network interruptions. The values used here are
safer, albeit with slightly extended failover times.
</para>
          </callout>
          <callout arearefs="CO1-2">
            <para>
With <literal>secauth</literal> enabled, Corosync nodes mutually authenticate using
a 128-byte shared secret stored in <literal>/etc/corosync/authkey</literal>, which may
be generated with the <literal>corosync-keygen</literal> utility. When using <literal>secauth</literal>,
cluster communications are also encrypted.
</para>
          </callout>
          <callout arearefs="CO1-3">
            <para>
In Corosync configurations using redundant networking (with more
than one <literal>interface</literal>), you must select a Redundant Ring Protocol (RRP)
mode other than <literal>none</literal>. <literal>active</literal> is the recommended RRP mode.
</para>
          </callout>
          <callout arearefs="CO1-4">
            <para>
There are several things to note about the recommended interface
configuration:
</para>
            <itemizedlist>
              <listitem>
                <simpara>
The <literal>ringnumber</literal> must differ between all configured interfaces,
  starting with 0.
</simpara>
              </listitem>
              <listitem>
                <simpara>
The <literal>bindnetaddr</literal> is the <emphasis>network</emphasis> address of the interfaces to bind
  to. The example uses two network addresses of <literal>/24</literal> IPv4 subnets.
</simpara>
              </listitem>
              <listitem>
                <simpara>
Multicast groups (<literal>mcastaddr</literal>) <emphasis>must not</emphasis> be reused across cluster
  boundaries. In other words, no two distinct clusters should ever use
  the same multicast group. Be sure to select multicast addresses
  compliant with <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.ietf.org/rfc/rfc2365.txt">RFC 2365,
  "Administratively Scoped IP Multicast"</link>.
</simpara>
              </listitem>
              <listitem>
                <simpara>
For firewall configurations, note that Corosync communicates over
  UDP only, and uses <literal>mcastport</literal> (for receives) and <literal>mcastport</literal>-1 (for
  sends).
</simpara>
              </listitem>
            </itemizedlist>
          </callout>
          <callout arearefs="CO1-5">
            <para>
The <literal>service</literal> declaration for the <literal>pacemaker</literal> service may be
placed in the <literal>corosync.conf</literal> file directly, or in its own separate
file, <literal>/etc/corosync/service.d/pacemaker</literal>.
</para>
          </callout>
        </calloutlist>
        <simpara>Once created, the <literal>corosync.conf</literal> file (and the <literal>authkey</literal> file if the
<literal>secauth</literal> option is enabled) must be synchronized across all cluster
nodes.</simpara>
      </section>
      <section xml:id="_starting_corosync">
        <info>
          <title>Starting Corosync</title>
        </info>
        <simpara>Corosync is started as a regular system service. Depending on your
distribution, it may ship with a LSB (System V style) init script, an
upstart job, or a systemd unit file. Either way, the service is
usually named <literal>corosync</literal>:</simpara>
        <itemizedlist>
          <listitem>
            <simpara><literal>/etc/init.d/corosync start</literal> (LSB)
</simpara>
          </listitem>
          <listitem>
            <simpara><literal>service corosync start</literal> (LSB, alternate)
</simpara>
          </listitem>
          <listitem>
            <simpara><literal>start corosync</literal> (upstart)
</simpara>
          </listitem>
          <listitem>
            <simpara><literal>systemctl start corosync</literal> (systemd)
</simpara>
          </listitem>
        </itemizedlist>
        <simpara>You can now check the Corosync connectivity with two tools.</simpara>
        <simpara>The <literal>corosync-cfgtool</literal> utility, when invoked with the <literal>-s</literal> option,
gives a summary of the health of the communication rings:</simpara>
        <screen># corosync-cfgtool -s
Printing ring status.
Local node ID 435324542
RING ID 0
        id      = 192.168.42.82
        status  = ring 0 active with no faults
RING ID 1
        id      = 10.0.42.100
        status  = ring 1 active with no faults</screen>
        <simpara>The <literal>corosync-objctl</literal> utility can be used to dump the Corosync cluster
member list:</simpara>
        <screen># corosync-objctl runtime.totem.pg.mrp.srp.members
runtime.totem.pg.mrp.srp.435324542.ip=r(0) ip(192.168.42.82) r(1) ip(10.0.42.100)
runtime.totem.pg.mrp.srp.435324542.join_count=1
runtime.totem.pg.mrp.srp.435324542.status=joined
runtime.totem.pg.mrp.srp.983895584.ip=r(0) ip(192.168.42.87) r(1) ip(10.0.42.254)
runtime.totem.pg.mrp.srp.983895584.join_count=1
runtime.totem.pg.mrp.srp.983895584.status=joined</screen>
        <simpara>You should see a <literal>status=joined</literal> entry for each of your constituent
cluster nodes.</simpara>
      </section>
      <section xml:id="_start_pacemaker">
        <info>
          <title>Start Pacemaker</title>
        </info>
        <simpara>Once the Corosync services have been started, and you have established
that the cluster is communicating properly, it is safe to start
<literal>pacemakerd</literal>, the Pacemaker master control process:</simpara>
        <itemizedlist>
          <listitem>
            <simpara><literal>/etc/init.d/pacemaker start</literal> (LSB)
</simpara>
          </listitem>
          <listitem>
            <simpara><literal>service pacemaker start</literal> (LSB, alternate)
</simpara>
          </listitem>
          <listitem>
            <simpara><literal>start pacemaker</literal> (upstart)
</simpara>
          </listitem>
          <listitem>
            <simpara><literal>systemctl start pacemaker</literal> (systemd)
</simpara>
          </listitem>
        </itemizedlist>
        <simpara>Once Pacemaker services have started, Pacemaker will create a default
empty cluster configuration with no resources. You may observe
Pacemaker’s status with the <literal>crm_mon</literal> utility:</simpara>
        <screen>============
Last updated: Sun Oct  7 21:07:52 2012
Last change: Sun Oct  7 20:46:00 2012 via cibadmin on node2
Stack: openais
Current DC: node2 - partition with quorum
Version: 1.1.6-9971ebba4494012a93c03b40a2c58ec0eb60f50c
2 Nodes configured, 2 expected votes
0 Resources configured.
============

Online: [ node2 node1 ]</screen>
      </section>
      <section xml:id="_set_basic_cluster_properties">
        <info>
          <title>Set basic cluster properties</title>
        </info>
        <simpara>Once your Pacemaker cluster is set up, it is recommended to set a few
basic cluster properties. To do so, start the <literal>crm</literal> shell and change
into the configuration menu by entering
<literal>configure</literal>. Alternatively. you may jump straight into the Pacemaker
configuration menu by typing <literal>crm configure</literal> directly from a shell
prompt.</simpara>
        <simpara>Then, set the following properties:</simpara>
        <screen>property no-quorum-policy="ignore" \ # <co xml:id="CO2-1"/>
  pe-warn-series-max="1000" \        # <co xml:id="CO2-2"/>
  pe-input-series-max="1000" \
  pe-error-series-max="1000" \
  cluster-recheck-interval="5min"    # <co xml:id="CO2-3"/></screen>
        <calloutlist>
          <callout arearefs="CO2-1">
            <para>
Setting <literal>no-quorum-policy="ignore"</literal> is required in 2-node Pacemaker
clusters for the following reason: if quorum enforcement is enabled,
and one of the two nodes fails, then the remaining node can not
establish a <emphasis>majority</emphasis> of quorum votes necessary to run services, and
thus it is unable to take over any resources. The appropriate
workaround is to ignore loss of quorum in the cluster. This is safe
and necessary <emphasis>only</emphasis> in 2-node clusters. Do not set this property in
Pacemaker clusters with more than two nodes.
</para>
          </callout>
          <callout arearefs="CO2-2">
            <para>
Setting <literal>pe-warn-series-max</literal>, <literal>pe-input-series-max</literal> and
<literal>pe-error-series-max</literal> to 1000 instructs Pacemaker to keep a longer
history of the inputs processed, and errors and warnings generated, by
its Policy Engine. This history is typically useful in case cluster
troubleshooting becomes necessary.
</para>
          </callout>
          <callout arearefs="CO2-3">
            <para>
Pacemaker uses an event-driven approach to cluster state
processing. However, certain Pacemaker actions occur at a configurable
interval, <literal>cluster-recheck-interval</literal>, which defaults to 15 minutes. It
is usually prudent to reduce this to a shorter interval, such as 5 or
3 minutes.
</para>
          </callout>
        </calloutlist>
        <simpara>Once you have made these changes, you may <literal>commit</literal> the updated
configuration.</simpara>
      </section>
    </section>
    <section xml:id="ch-controller">
      <info>
        <title>Cloud controller cluster stack</title>
      </info>
      <simpara>The cloud controller runs on the management network and must talk to all other services.</simpara>
      <section xml:id="s-mysql">
        <info>
          <title>Highly available MySQL</title>
        </info>
        <simpara>MySQL is the default database server used by many OpenStack
services. Making the MySQL service highly available involves</simpara>
        <itemizedlist>
          <listitem>
            <simpara>
Configure a DRBD device for use by MySQL,
</simpara>
          </listitem>
          <listitem>
            <simpara>
Configure MySQL to use a data directory residing on that DRBD
  device,
</simpara>
          </listitem>
          <listitem>
            <simpara>
selecting and assigning a virtual IP address (VIP) that can freely
  float between cluster nodes,
</simpara>
          </listitem>
          <listitem>
            <simpara>
Configure MySQL to listen on that IP address,
</simpara>
          </listitem>
          <listitem>
            <simpara>
managing all resources, including the MySQL daemon itself, with
  the Pacemaker cluster manager.
</simpara>
          </listitem>
        </itemizedlist>
        <note>
          <simpara><link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://codership.com/products/mysql_galera">MySQL/Galera</link> is an
alternative method of Configure MySQL for high availability. It is
likely to become the preferred method of achieving MySQL high
availability once it has sufficiently matured. At the time of writing,
however, the Pacemaker/DRBD based approach remains the recommended one
for OpenStack environments.</simpara>
        </note>
        <section xml:id="_configure_drbd">
          <info>
            <title>Configure DRBD</title>
          </info>
          <simpara>The Pacemaker based MySQL server requires a DRBD resource from
which it mounts the <literal>/var/lib/mysql</literal> directory. In this example,
the DRBD resource is simply named <literal>mysql</literal>:</simpara>
          <formalpara>
            <info>
              <title><literal>mysql</literal> DRBD resource configuration (<literal>/etc/drbd.d/mysql.res</literal>)</title>
            </info>
            <para>
              <screen>resource mysql {
  device    minor 0;
  disk      "/dev/data/mysql";
  meta-disk internal;
  on node1 {
    address ipv4 10.0.42.100:7700;
  }
  on node2 {
    address ipv4 10.0.42.254:7700;
  }
}</screen>
            </para>
          </formalpara>
          <simpara>This resource uses an underlying local disk (in DRBD terminology, a
<emphasis>backing device</emphasis>) named <literal>/dev/data/mysql</literal> on both cluster nodes,
<literal>node1</literal> and <literal>node2</literal>. Normally, this would be an LVM Logical Volume
specifically set aside for this purpose. The DRBD <literal>meta-disk</literal> is
<literal>internal</literal>, meaning DRBD-specific metadata is being stored at the end
of the <literal>disk</literal> device itself. The device is configured to communicate
between IPv4 addresses 10.0.42.100 and 10.0.42.254, using TCP port
7700. Once enabled, it will map to a local DRBD block device with the
device minor number 0, that is, <literal>/dev/drbd0</literal>.</simpara>
          <simpara>Enabling a DRBD resource is explained in detail in
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.drbd.org/users-guide-8.3/s-first-time-up.html">the DRBD
User’s Guide</link>. In brief, the proper sequence of commands is this:</simpara>
          <screen>drbdadm create-md mysql <co xml:id="CO3-1"/>
drbdadm up mysql <co xml:id="CO3-2"/>
drbdadm -- --force primary mysql <co xml:id="CO3-3"/></screen>
          <calloutlist>
            <callout arearefs="CO3-1">
              <para>
Initializes DRBD metadata and writes the initial set of metadata
to <literal>/dev/data/mysql</literal>. Must be completed on both nodes.
</para>
            </callout>
            <callout arearefs="CO3-2">
              <para>
Creates the <literal>/dev/drbd0</literal> device node, <emphasis>attaches</emphasis> the DRBD device
to its backing store, and <emphasis>connects</emphasis> the DRBD node to its peer. Must
be completed on both nodes.
</para>
            </callout>
            <callout arearefs="CO3-3">
              <para>
Kicks off the initial device synchronization, and puts the device
into the <literal>primary</literal> (readable and writable) role. See
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.drbd.org/users-guide-8.3/ch-admin.html#s-roles">Resource
roles</link> (from the DRBD User’s Guide) for a more detailed description of
the primary and secondary roles in DRBD. Must be completed <emphasis>on one
node only,</emphasis> namely the one where you are about to continue with
creating your filesystem.
</para>
            </callout>
          </calloutlist>
        </section>
        <section xml:id="_creating_a_file_system">
          <info>
            <title>Creating a file system</title>
          </info>
          <simpara>Once the DRBD resource is running and in the primary role (and
potentially still in the process of running the initial device
synchronization), you may proceed with creating the filesystem for
MySQL data. XFS is the generally recommended filesystem:</simpara>
          <screen>mkfs -t xfs /dev/drbd0</screen>
          <simpara>You may also use the alternate device path for the DRBD device, which
may be easier to remember as it includes the self-explanatory resource
name:</simpara>
          <screen>mkfs -t xfs /dev/drbd/by-res/mysql</screen>
          <simpara>Once completed, you may safely return the device to the secondary
role. Any ongoing device synchronization will continue in the
background:</simpara>
          <screen>drbdadm secondary mysql</screen>
        </section>
        <section xml:id="_prepare_mysql_for_pacemaker_high_availability">
          <info>
            <title>Prepare MySQL for Pacemaker high availability</title>
          </info>
          <simpara>In order for Pacemaker monitoring to function properly, you must
ensure that MySQL’s database files reside on the DRBD device. If you
already have an existing MySQL database, the simplest approach is to
just move the contents of the existing <literal>/var/lib/mysql</literal> directory into
the newly created filesystem on the DRBD device.</simpara>
          <warning>
            <simpara>You must complete the next step while the MySQL database
server is shut down.</simpara>
          </warning>
          <screen>node1:# mount /dev/drbd/by-res/mysql /mnt
node1:# mv /var/lib/mysql/* /mnt
node1:# umount /mnt</screen>
          <simpara>For a new MySQL installation with no existing data, you may also run
the <literal>mysql_install_db</literal> command:</simpara>
          <screen>node1:# mount /dev/drbd/by-res/mysql /mnt
node1:# mysql_install_db --datadir=/mnt
node1:# umount /mnt</screen>
          <simpara>Regardless of the approach, the steps outlined here must be completed
on only one cluster node.</simpara>
        </section>
        <section xml:id="_add_mysql_resources_to_pacemaker">
          <info>
            <title>Add MySQL resources to Pacemaker</title>
          </info>
          <simpara>You can now add the Pacemaker configuration for
MySQL resources. Connect to the Pacemaker cluster with <literal>crm
configure</literal>, and add the following cluster resources:</simpara>
          <screen>primitive p_ip_mysql ocf:heartbeat:IPaddr2 \
  params ip="192.168.42.101" cidr_netmask="24" \
  op monitor interval="30s"
primitive p_drbd_mysql ocf:linbit:drbd \
  params drbd_resource="mysql" \
  op start timeout="90s" \
  op stop timeout="180s" \
  op promote timeout="180s" \
  op demote timeout="180s" \
  op monitor interval="30s" role="Slave" \
  op monitor interval="29s" role="Master"
primitive p_fs_mysql ocf:heartbeat:Filesystem \
  params device="/dev/drbd/by-res/mysql" \
    directory="/var/lib/mysql" \
    fstype="xfs" \
    options="relatime" \
  op start timeout="60s" \
  op stop timeout="180s" \
  op monitor interval="60s" timeout="60s"
primitive p_mysql ocf:heartbeat:mysql \
  params additional_parameters="--bind-address=50.56.179.138"
    config="/etc/mysql/my.cnf" \
    pid="/var/run/mysqld/mysqld.pid" \
    socket="/var/run/mysqld/mysqld.sock" \
    log="/var/log/mysql/mysqld.log" \
  op monitor interval="20s" timeout="10s" \
  op start timeout="120s" \
  op stop timeout="120s"
group g_mysql p_ip_mysql p_fs_mysql p_mysql
ms ms_drbd_mysql p_drbd_mysql \
  meta notify="true" clone-max="2"
colocation c_mysql_on_drbd inf: g_mysql ms_drbd_mysql:Master
order o_drbd_before_mysql inf: ms_drbd_mysql:promote g_mysql:start</screen>
          <simpara>This configuration creates</simpara>
          <itemizedlist>
            <listitem>
              <simpara><literal>p_ip_mysql</literal>, a virtual IP address for use by MySQL
  (192.168.42.101),
</simpara>
            </listitem>
            <listitem>
              <simpara><literal>p_fs_mysql</literal>, a Pacemaker managed filesystem mounted to
  <literal>/var/lib/mysql</literal> on whatever node currently runs the MySQL
  service,
</simpara>
            </listitem>
            <listitem>
              <simpara><literal>ms_drbd_mysql</literal>, the <emphasis>master/slave set</emphasis> managing the <literal>mysql</literal>
  DRBD resource,
</simpara>
            </listitem>
            <listitem>
              <simpara>
a service <literal>group</literal> and <literal>order</literal> and <literal>colocation</literal> constraints to ensure
  resources are started on the correct nodes, and in the correct sequence.
</simpara>
            </listitem>
          </itemizedlist>
          <simpara><literal>crm configure</literal> supports batch input, so you may copy and paste the
above into your live pacemaker configuration, and then make changes as
required. For example, you may enter <literal>edit p_ip_mysql</literal> from the
<literal>crm configure</literal> menu and edit the resource to match your preferred
virtual IP address.</simpara>
          <simpara>Once completed, commit your configuration changes by entering <literal>commit</literal>
from the <literal>crm configure</literal> menu. Pacemaker will then start the MySQL
service, and its dependent resources, on one of your nodes.</simpara>
        </section>
        <section xml:id="_configure_openstack_services_for_highly_available_mysql">
          <info>
            <title>Configure OpenStack services for highly available MySQL</title>
          </info>
          <simpara>Your OpenStack services must now point their MySQL configuration to
the highly available, virtual cluster IP address — rather than a
MySQL server’s physical IP address as you normally would.</simpara>
          <simpara>For OpenStack Image, for example, if your MySQL service IP address is
192.168.42.101 as in the configuration explained here, you would use
the following line in your OpenStack Image registry configuration file
(<literal>glance-registry.conf</literal>):</simpara>
          <screen>sql_connection = mysql://glancedbadmin:&lt;password&gt;@192.168.42.101/glance</screen>
          <simpara>No other changes are necessary to your OpenStack configuration. If the
node currently hosting your database experiences a problem
necessitating service failover, your OpenStack services may experience
a brief MySQL interruption, as they would in the event of a network
hiccup, and then continue to run normally.</simpara>
        </section>
      </section>
      <section xml:id="s-rabbitmq">
        <info>
          <title>Highly available RabbitMQ</title>
        </info>
        <simpara>RabbitMQ is the default AMQP server used by many OpenStack
services. Making the RabbitMQ service highly available involves:</simpara>
        <itemizedlist>
          <listitem>
            <simpara>
configuring a DRBD device for use by RabbitMQ,
</simpara>
          </listitem>
          <listitem>
            <simpara>
configuring RabbitMQ to use a data directory residing on that DRBD
  device,
</simpara>
          </listitem>
          <listitem>
            <simpara>
selecting and assigning a virtual IP address (VIP) that can freely
  float between cluster nodes,
</simpara>
          </listitem>
          <listitem>
            <simpara>
configuring RabbitMQ to listen on that IP address,
</simpara>
          </listitem>
          <listitem>
            <simpara>
managing all resources, including the RabbitMQ daemon itself, with
  the Pacemaker cluster manager.
</simpara>
          </listitem>
        </itemizedlist>
        <note>
          <simpara>There is an alternative method of configuring RabbitMQ for high
availability. That approach, known as
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.rabbitmq.com/ha.html">active-active mirrored queues</link>,
happens to be the one preferred by the RabbitMQ developers — however
it has shown less than ideal consistency and reliability in OpenStack
clusters. Thus, at the time of writing, the Pacemaker/DRBD based
approach remains the recommended one for OpenStack environments,
although this may change in the near future as RabbitMQ active-active
mirrored queues mature.</simpara>
        </note>
        <section xml:id="_configure_drbd_2">
          <info>
            <title>Configure DRBD</title>
          </info>
          <simpara>The Pacemaker based RabbitMQ server requires a DRBD resource from
which it mounts the <literal>/var/lib/rabbitmq</literal> directory. In this example,
the DRBD resource is simply named <literal>rabbitmq</literal>:</simpara>
          <formalpara>
            <info>
              <title><literal>rabbitmq</literal> DRBD resource configuration (<literal>/etc/drbd.d/rabbitmq.res</literal>)</title>
            </info>
            <para>
              <screen>resource rabbitmq {
  device    minor 1;
  disk      "/dev/data/rabbitmq";
  meta-disk internal;
  on node1 {
    address ipv4 10.0.42.100:7701;
  }
  on node2 {
    address ipv4 10.0.42.254:7701;
  }
}</screen>
            </para>
          </formalpara>
          <simpara>This resource uses an underlying local disk (in DRBD terminology, a
<emphasis>backing device</emphasis>) named <literal>/dev/data/rabbitmq</literal> on both cluster nodes,
<literal>node1</literal> and <literal>node2</literal>. Normally, this would be an LVM Logical Volume
specifically set aside for this purpose. The DRBD <literal>meta-disk</literal> is
<literal>internal</literal>, meaning DRBD-specific metadata is being stored at the end
of the <literal>disk</literal> device itself. The device is configured to communicate
between IPv4 addresses 10.0.42.100 and 10.0.42.254, using TCP port
7701. Once enabled, it will map to a local DRBD block device with the
device minor number 1, that is, <literal>/dev/drbd1</literal>.</simpara>
          <simpara>Enabling a DRBD resource is explained in detail in
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.drbd.org/users-guide-8.3/s-first-time-up.html">the DRBD
User’s Guide</link>. In brief, the proper sequence of commands is this:</simpara>
          <screen>drbdadm create-md rabbitmq <co xml:id="CO4-1"/>
drbdadm up rabbitmq <co xml:id="CO4-2"/>
drbdadm -- --force primary rabbitmq <co xml:id="CO4-3"/></screen>
          <calloutlist>
            <callout arearefs="CO4-1">
              <para>
Initializes DRBD metadata and writes the initial set of metadata
to <literal>/dev/data/rabbitmq</literal>. Must be completed on both nodes.
</para>
            </callout>
            <callout arearefs="CO4-2">
              <para>
Creates the <literal>/dev/drbd1</literal> device node, <emphasis>attaches</emphasis> the DRBD device
to its backing store, and <emphasis>connects</emphasis> the DRBD node to its peer. Must
be completed on both nodes.
</para>
            </callout>
            <callout arearefs="CO4-3">
              <para>
Kicks off the initial device synchronization, and puts the device
into the <literal>primary</literal> (readable and writable) role. See
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.drbd.org/users-guide-8.3/ch-admin.html#s-roles">Resource
roles</link> (from the DRBD User’s Guide) for a more detailed description of
the primary and secondary roles in DRBD. Must be completed <emphasis>on one
node only,</emphasis> namely the one where you are about to continue with
creating your filesystem.
</para>
            </callout>
          </calloutlist>
        </section>
        <section xml:id="_create_a_file_system">
          <info>
            <title>Create a file system</title>
          </info>
          <simpara>Once the DRBD resource is running and in the primary role (and
potentially still in the process of running the initial device
synchronization), you may proceed with creating the filesystem for
RabbitMQ data. XFS is generally the recommended filesystem:</simpara>
          <screen>mkfs -t xfs /dev/drbd1</screen>
          <simpara>You may also use the alternate device path for the DRBD device, which
may be easier to remember as it includes the self-explanatory resource
name:</simpara>
          <screen>mkfs -t xfs /dev/drbd/by-res/rabbitmq</screen>
          <simpara>Once completed, you may safely return the device to the secondary
role. Any ongoing device synchronization will continue in the
background:</simpara>
          <screen>drbdadm secondary rabbitmq</screen>
        </section>
        <section xml:id="_prepare_rabbitmq_for_pacemaker_high_availability">
          <info>
            <title>Prepare RabbitMQ for Pacemaker high availability</title>
          </info>
          <simpara>In order for Pacemaker monitoring to function properly, you must
ensure that RabbitMQ’s <literal>.erlang.cookie</literal> files are identical on all
nodes, regardless of whether DRBD is mounted there or not. The
simplest way of doing so is to take an existing <literal>.erlang.cookie</literal> from
one of your nodes, copying it to the RabbitMQ data directory on the
other node, and also copying it to the DRBD-backed filesystem.</simpara>
          <screen>node1:# scp -a /var/lib/rabbitmq/.erlang.cookie node2:/var/lib/rabbitmq/
node1:# mount /dev/drbd/by-res/rabbitmq /mnt
node1:# cp -a /var/lib/rabbitmq/.erlang.cookie /mnt
node1:# umount /mnt</screen>
        </section>
        <section xml:id="_add_rabbitmq_resources_to_pacemaker">
          <info>
            <title>Add RabbitMQ resources to Pacemaker</title>
          </info>
          <simpara>You may now proceed with adding the Pacemaker configuration for
RabbitMQ resources. Connect to the Pacemaker cluster with <literal>crm
configure</literal>, and add the following cluster resources:</simpara>
          <screen>primitive p_ip_rabbitmp ocf:heartbeat:IPaddr2 \
  params ip="192.168.42.100" cidr_netmask="24" \
  op monitor interval="10s"
primitive p_drbd_rabbitmq ocf:linbit:drbd \
  params drbd_resource="rabbitmq" \
  op start timeout="90s" \
  op stop timeout="180s" \
  op promote timeout="180s" \
  op demote timeout="180s" \
  op monitor interval="30s" role="Slave" \
  op monitor interval="29s" role="Master"
primitive p_fs_rabbitmq ocf:heartbeat:Filesystem \
  params device="/dev/drbd/by-res/rabbitmq" \
    directory="/var/lib/rabbitmq" \
    fstype="xfs" options="relatime" \
  op start timeout="60s" \
  op stop timeout="180s" \
  op monitor interval="60s" timeout="60s"
primitive p_rabbitmq ocf:rabbitmq:rabbitmq-server \
  params nodename="rabbit@localhost" \
    mnesia_base="/var/lib/rabbitmq" \
  op monitor interval="20s" timeout="10s"
group g_rabbitmq p_ip_rabbitmq p_fs_rabbitmq p_rabbitmq
ms ms_drbd_rabbitmq p_drbd_rabbitmq \
  meta notify="true" master-max="1" clone-max="2"
colocation c_rabbitmq_on_drbd inf: g_rabbitmq ms_drbd_rabbitmq:Master
order o_drbd_before_rabbitmq inf: ms_drbd_rabbitmq:promote g_rabbitmq:start</screen>
          <simpara>This configuration creates</simpara>
          <itemizedlist>
            <listitem>
              <simpara><literal>p_ip_rabbitmp</literal>, a virtual IP address for use by RabbitMQ
  (192.168.42.100),
</simpara>
            </listitem>
            <listitem>
              <simpara><literal>p_fs_rabbitmq</literal>, a Pacemaker managed filesystem mounted to
  <literal>/var/lib/rabbitmq</literal> on whatever node currently runs the RabbitMQ
  service,
</simpara>
            </listitem>
            <listitem>
              <simpara><literal>ms_drbd_rabbitmq</literal>, the <emphasis>master/slave set</emphasis> managing the <literal>rabbitmq</literal>
  DRBD resource,
</simpara>
            </listitem>
            <listitem>
              <simpara>
a service <literal>group</literal> and <literal>order</literal> and <literal>colocation</literal> constraints to ensure
  resources are started on the correct nodes, and in the correct sequence.
</simpara>
            </listitem>
          </itemizedlist>
          <simpara><literal>crm configure</literal> supports batch input, so you may copy and paste the
above into your live pacemaker configuration, and then make changes as
required. For example, you may enter <literal>edit p_ip_rabbitmq</literal> from the
<literal>crm configure</literal> menu and edit the resource to match your preferred
virtual IP address.</simpara>
          <simpara>Once completed, commit your configuration changes by entering <literal>commit</literal>
from the <literal>crm configure</literal> menu. Pacemaker will then start the RabbitMQ
service, and its dependent resources, on one of your nodes.</simpara>
        </section>
        <section xml:id="_configure_openstack_services_for_highly_available_rabbitmq">
          <info>
            <title>Configure OpenStack services for highly available RabbitMQ</title>
          </info>
          <simpara>Your OpenStack services must now point their RabbitMQ configuration to
the highly available, virtual cluster IP address — rather than a
RabbitMQ server’s physical IP address as you normally would.</simpara>
          <simpara>For OpenStack Image, for example, if your RabbitMQ service IP address is
192.168.42.100 as in the configuration explained here, you would use
the following line in your OpenStack Image API configuration file
(<literal>glance-api.conf</literal>):</simpara>
          <screen>rabbit_host = 192.168.42.100</screen>
          <simpara>No other changes are necessary to your OpenStack configuration. If the
node currently hosting your RabbitMQ experiences a problem
necessitating service failover, your OpenStack services may experience
a brief RabbitMQ interruption, as they would in the event of a network
hiccup, and then continue to run normally.</simpara>
        </section>
      </section>
    </section>
    <section xml:id="ch-api">
      <info>
        <title>API node cluster stack</title>
      </info>
      <simpara>The API node exposes OpenStack API endpoints onto external network (Internet).
It must talk to the cloud controller on the management network.</simpara>
      <section xml:id="s-api-vip">
        <info>
          <title>Configure the VIP</title>
        </info>
        <simpara>First, you must select and assign a virtual IP address (VIP) that can freely float between cluster nodes.</simpara>
        <simpara>This configuration creates <literal>p_ip_api</literal>, a virtual IP address for use by the API node (192.168.42.103) :</simpara>
        <screen>primitive p_api-ip ocf:heartbeat:IPaddr2 \
    params ip="192.168.42.103" cidr_netmask="24" \
    op monitor interval="30s"</screen>
      </section>
      <section xml:id="s-keystone">
        <info>
          <title>Highly available OpenStack Identity</title>
        </info>
        <simpara>OpenStack Identity is the Identity Service in OpenStack and used by many services.
Making the OpenStack Identity service highly available in active / passive mode involves</simpara>
        <itemizedlist>
          <listitem>
            <simpara>
Configure OpenStack Identity to listen on the VIP address,
</simpara>
          </listitem>
          <listitem>
            <simpara>
managing OpenStack Identity daemon with the Pacemaker cluster manager,
</simpara>
          </listitem>
          <listitem>
            <simpara>
Configure OpenStack services to use this IP address.
</simpara>
          </listitem>
        </itemizedlist>
        <note>
          <simpara>Here is the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.openstack.org/trunk/install-guide/install/apt/content/ch_installing-openstack-identity-service.html">documentation</link> for installing OpenStack Identity service.</simpara>
        </note>
        <section xml:id="_add_openstack_identity_resource_to_pacemaker">
          <info>
            <title>Add OpenStack Identity resource to Pacemaker</title>
          </info>
          <simpara>First of all, you need to download the resource agent to your system:</simpara>
          <screen>cd /usr/lib/ocf/resource.d
mkdir openstack
cd openstack
wget https://raw.github.com/madkiss/openstack-resource-agents/master/ocf/keystone
chmod a+rx *</screen>
          <simpara>You can now add the Pacemaker configuration for
OpenStack Identity resource. Connect to the Pacemaker cluster with <literal>crm
configure</literal>, and add the following cluster resources:</simpara>
          <screen>primitive p_keystone ocf:openstack:keystone \
  params config="/etc/keystone/keystone.conf" os_password="secret" os_username="admin" os_tenant_name="admin" os_auth_url="http://192.168.42.103:5000/v2.0/" \
  op monitor interval="30s" timeout="30s"</screen>
          <simpara>This configuration creates <literal>p_keystone</literal>, a resource for managing the OpenStack Identity service.</simpara>
          <simpara><literal>crm configure</literal> supports batch input, so you may copy and paste the
above into your live pacemaker configuration, and then make changes as
required. For example, you may enter <literal>edit p_ip_keystone</literal> from the
<literal>crm configure</literal> menu and edit the resource to match your preferred
virtual IP address.</simpara>
          <simpara>Once completed, commit your configuration changes by entering <literal>commit</literal>
from the <literal>crm configure</literal> menu. Pacemaker will then start the OpenStack Identity
service, and its dependent resources, on one of your nodes.</simpara>
        </section>
        <section xml:id="_configure_openstack_identity_service">
          <info>
            <title>Configure OpenStack Identity service</title>
          </info>
          <simpara>You need to edit your OpenStack Identity configuration file (<literal>keystone.conf</literal>) and change the bind parameters:</simpara>
          <simpara>On Havana:</simpara>
          <screen>bind_host = 192.168.42.103</screen>
          <simpara>On Icehouse, the <literal>admin_bind_host</literal> option lets you use a private network for the admin access.</simpara>
          <screen>public_bind_host = 192.168.42.103
admin_bind_host = 192.168.42.103</screen>
          <simpara>To be sure all data will be highly available, you should be sure that you store everything in the MySQL database (which is also highly available):</simpara>
          <screen>[catalog]
driver = keystone.catalog.backends.sql.Catalog
...
[identity]
driver = keystone.identity.backends.sql.Identity
...</screen>
        </section>
        <section xml:id="_configure_openstack_services_to_use_the_highly_available_openstack_identity">
          <info>
            <title>Configure OpenStack services to use the highly available OpenStack Identity</title>
          </info>
          <simpara>Your OpenStack services must now point their OpenStack Identity configuration to
the highly available, virtual cluster IP address — rather than a
OpenStack Identity server’s physical IP address as you normally would.</simpara>
          <simpara>For example with OpenStack Compute, if your OpenStack Identity service IP address is
192.168.42.103 as in the configuration explained here, you would use
the following line in your API configuration file
(<literal>api-paste.ini</literal>):</simpara>
          <screen>auth_host = 192.168.42.103</screen>
          <simpara>You also need to create the OpenStack Identity Endpoint with this IP.</simpara>
          <simpara>NOTE : If you are using both private and public IP addresses, you should create two Virtual IP addresses and define your endpoint like this:</simpara>
          <screen>keystone endpoint-create --region $KEYSTONE_REGION --service-id $service-id --publicurl 'http://PUBLIC_VIP:5000/v2.0' --adminurl 'http://192.168.42.103:35357/v2.0' --internalurl 'http://192.168.42.103:5000/v2.0'</screen>
          <simpara>If you are using the horizon dashboard, you should edit the <literal>local_settings.py</literal> file:</simpara>
          <screen>OPENSTACK_HOST = 192.168.42.103</screen>
        </section>
      </section>
      <section xml:id="s-glance-api">
        <info>
          <title>Highly available OpenStack Image API</title>
        </info>
        <simpara>OpenStack Image Service offers a service for discovering, registering, and retrieving virtual machine images.
To make the OpenStack Image API service highly available in active / passive mode, you must:</simpara>
        <itemizedlist>
          <listitem>
            <simpara>
Configure OpenStack Image to listen on the VIP address.
</simpara>
          </listitem>
          <listitem>
            <simpara>
Manage OpenStack Image API daemon with the Pacemaker cluster manager.
</simpara>
          </listitem>
          <listitem>
            <simpara>
Configure OpenStack services to use this IP address.
</simpara>
          </listitem>
        </itemizedlist>
        <note>
          <simpara>Here is the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.openstack.org/trunk/install-guide/install/apt/content/ch_installing-openstack-image.html">documentation</link> for installing OpenStack Image API service.</simpara>
        </note>
        <section xml:id="_add_openstack_image_api_resource_to_pacemaker">
          <info>
            <title>Add OpenStack Image API resource to Pacemaker</title>
          </info>
          <simpara>First of all, you need to download the resource agent to your system:</simpara>
          <screen>cd /usr/lib/ocf/resource.d/openstack
wget https://raw.github.com/madkiss/openstack-resource-agents/master/ocf/glance-api
chmod a+rx *</screen>
          <simpara>You can now add the Pacemaker configuration for
OpenStack Image API resource. Connect to the Pacemaker cluster with <literal>crm
configure</literal>, and add the following cluster resources:</simpara>
          <screen>primitive p_glance-api ocf:openstack:glance-api \
    params config="/etc/glance/glance-api.conf" os_password="secrete" os_username="admin" os_tenant_name="admin" os_auth_url="http://192.168.42.103:5000/v2.0/" \
    op monitor interval="30s" timeout="30s"</screen>
          <simpara>This configuration creates</simpara>
          <itemizedlist>
            <listitem>
              <simpara><literal>p_glance-api</literal>, a resource for manage OpenStack Image API service
</simpara>
            </listitem>
          </itemizedlist>
          <simpara><literal>crm configure</literal> supports batch input, so you may copy and paste the
above into your live pacemaker configuration, and then make changes as
required. For example, you may enter <literal>edit p_ip_glance-api</literal> from the
<literal>crm configure</literal> menu and edit the resource to match your preferred
virtual IP address.</simpara>
          <simpara>Once completed, commit your configuration changes by entering <literal>commit</literal>
from the <literal>crm configure</literal> menu. Pacemaker will then start the OpenStack Image API
service, and its dependent resources, on one of your nodes.</simpara>
        </section>
        <section xml:id="_configure_openstack_image_service_api">
          <info>
            <title>Configure OpenStack Image Service API</title>
          </info>
          <simpara>Edit <literal>/etc/glance/glance-api.conf</literal>:</simpara>
          <screen># We have to use MySQL connection to store data:
sql_connection=mysql://glance:password@192.168.42.101/glance

# We bind OpenStack Image API to the VIP:
bind_host = 192.168.42.103

# Connect to OpenStack Image Registry service:
registry_host = 192.168.42.103

# We send notifications to High Available RabbitMQ:
notifier_strategy = rabbit
rabbit_host = 192.168.42.102</screen>
        </section>
        <section xml:id="_configure_openstack_services_to_use_high_available_openstack_image_api">
          <info>
            <title>Configure OpenStack services to use high available OpenStack Image API</title>
          </info>
          <simpara>Your OpenStack services must now point their OpenStack Image API configuration to
the highly available, virtual cluster IP address — rather than an
OpenStack Image API server’s physical IP address as you normally would.</simpara>
          <simpara>For OpenStack Compute, for example, if your OpenStack Image API service IP address is
192.168.42.104 as in the configuration explained here, you would use
the following line in your <literal>nova.conf</literal> file:</simpara>
          <screen>glance_api_servers = 192.168.42.103</screen>
          <simpara>You must also create the OpenStack Image API endpoint with this IP.</simpara>
          <note>
            <simpara>If you are using both private and public IP addresses, you should create two Virtual IP addresses and define your endpoint like this:</simpara>
          </note>
          <screen>keystone endpoint-create --region $KEYSTONE_REGION --service-id $service-id --publicurl 'http://PUBLIC_VIP:9292' --adminurl 'http://192.168.42.103:9292' --internalurl 'http://192.168.42.103:9292'</screen>
        </section>
      </section>
      <section xml:id="s-cinder-api">
        <info>
          <title>Highly available Block Storage API</title>
        </info>
        <simpara>Making the Block Storage (cinder) API service highly available in active / passive mode involves</simpara>
        <itemizedlist>
          <listitem>
            <simpara>
Configure Block Storage to listen on the VIP address,
</simpara>
          </listitem>
          <listitem>
            <simpara>
managing Block Storage API daemon with the Pacemaker cluster manager,
</simpara>
          </listitem>
          <listitem>
            <simpara>
Configure OpenStack services to use this IP address.
</simpara>
          </listitem>
        </itemizedlist>
        <note>
          <simpara>Here is the
<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.openstack.org/trunk/install-guide/install/apt/content/ch_cinder.html">documentation</link>
for installing Block Storage service.</simpara>
        </note>
        <section xml:id="_add_block_storage_api_resource_to_pacemaker">
          <info>
            <title>Add Block Storage API resource to Pacemaker</title>
          </info>
          <simpara>First of all, you need to download the resource agent to your system:</simpara>
          <screen>cd /usr/lib/ocf/resource.d/openstack
wget https://raw.github.com/madkiss/openstack-resource-agents/master/ocf/cinder-api
chmod a+rx *</screen>
          <simpara>You can now add the Pacemaker configuration for
Block Storage API resource. Connect to the Pacemaker cluster with <literal>crm
configure</literal>, and add the following cluster resources:</simpara>
          <screen>primitive p_cinder-api ocf:openstack:cinder-api \
    params config="/etc/cinder/cinder.conf" os_password="secrete" os_username="admin" \
    os_tenant_name="admin" keystone_get_token_url="http://192.168.42.103:5000/v2.0/tokens" \
    op monitor interval="30s" timeout="30s"</screen>
          <simpara>This configuration creates</simpara>
          <itemizedlist>
            <listitem>
              <simpara><literal>p_cinder-api</literal>, a resource for manage Block Storage API service
</simpara>
            </listitem>
          </itemizedlist>
          <simpara><literal>crm configure</literal> supports batch input, so you may copy and paste the
above into your live pacemaker configuration, and then make changes as
required. For example, you may enter <literal>edit p_ip_cinder-api</literal> from the
<literal>crm configure</literal> menu and edit the resource to match your preferred
virtual IP address.</simpara>
          <simpara>Once completed, commit your configuration changes by entering <literal>commit</literal>
from the <literal>crm configure</literal> menu. Pacemaker will then start the Block Storage API
service, and its dependent resources, on one of your nodes.</simpara>
        </section>
        <section xml:id="_configure_block_storage_api_service">
          <info>
            <title>Configure Block Storage API service</title>
          </info>
          <simpara>Edit <literal>/etc/cinder/cinder.conf</literal>:</simpara>
          <screen># We have to use MySQL connection to store data:
sql_connection=mysql://cinder:password@192.168.42.101/cinder

# We bind Block Storage API to the VIP:
osapi_volume_listen = 192.168.42.103

# We send notifications to High Available RabbitMQ:
notifier_strategy = rabbit
rabbit_host = 192.168.42.102</screen>
        </section>
        <section xml:id="_configure_openstack_services_to_use_highly_available_block_storage_api">
          <info>
            <title>Configure OpenStack services to use highly available Block Storage API</title>
          </info>
          <simpara>Your OpenStack services must now point their Block Storage API configuration to
the highly available, virtual cluster IP address — rather than a
Block Storage API server’s physical IP address as you normally would.</simpara>
          <simpara>You must create the Block Storage API endpoint with this IP.</simpara>
          <note>
            <simpara>If you are using both private and public IP, you should create two Virtual IPs and define your endpoint like this:</simpara>
          </note>
          <screen>keystone endpoint-create --region $KEYSTONE_REGION --service-id $service-id --publicurl 'http://PUBLIC_VIP:8776/v1/%(tenant_id)s' --adminurl 'http://192.168.42.103:8776/v1/%(tenant_id)s' --internalurl 'http://192.168.42.103:8776/v1/%(tenant_id)s'</screen>
        </section>
      </section>
      <section xml:id="s-neutron-server">
        <info>
          <title>Highly available OpenStack Networking server</title>
        </info>
        <simpara>OpenStack Networking is the network connectivity service in OpenStack.
Making the OpenStack Networking Server service highly available in active / passive mode involves</simpara>
        <itemizedlist>
          <listitem>
            <simpara>
Configure OpenStack Networking to listen on the VIP address,
</simpara>
          </listitem>
          <listitem>
            <simpara>
managing OpenStack Networking API Server daemon with the Pacemaker cluster manager,
</simpara>
          </listitem>
          <listitem>
            <simpara>
Configure OpenStack services to use this IP address.
</simpara>
          </listitem>
        </itemizedlist>
        <note>
          <simpara>Here is the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.openstack.org/trunk/install-guide/install/apt/content/ch_installing-openstack-networking.html">documentation</link> for installing OpenStack Networking service.</simpara>
        </note>
        <section xml:id="_add_openstack_networking_server_resource_to_pacemaker">
          <info>
            <title>Add OpenStack Networking Server resource to Pacemaker</title>
          </info>
          <simpara>First of all, you need to download the resource agent to your system:</simpara>
          <screen>cd /usr/lib/ocf/resource.d/openstack
wget https://raw.github.com/madkiss/openstack-resource-agents/master/ocf/neutron-server
chmod a+rx *</screen>
          <simpara>You can now add the Pacemaker configuration for
OpenStack Networking Server resource. Connect to the Pacemaker cluster with <literal>crm
configure</literal>, and add the following cluster resources:</simpara>
          <screen>primitive p_neutron-server ocf:openstack:neutron-server \
    params os_password="secrete" os_username="admin" os_tenant_name="admin" \
    keystone_get_token_url="http://192.168.42.103:5000/v2.0/tokens" \
    op monitor interval="30s" timeout="30s"</screen>
          <simpara>This configuration creates <literal>p_neutron-server</literal>, a resource for manage OpenStack Networking Server service</simpara>
          <simpara><literal>crm configure</literal> supports batch input, so you may copy and paste the
above into your live pacemaker configuration, and then make changes as
required. For example, you may enter <literal>edit p_neutron-server</literal> from the
<literal>crm configure</literal> menu and edit the resource to match your preferred
virtual IP address.</simpara>
          <simpara>Once completed, commit your configuration changes by entering <literal>commit</literal>
from the <literal>crm configure</literal> menu. Pacemaker will then start the OpenStack Networking API
service, and its dependent resources, on one of your nodes.</simpara>
        </section>
        <section xml:id="_configure_openstack_networking_server">
          <info>
            <title>Configure OpenStack Networking server</title>
          </info>
          <simpara>Edit <literal>/etc/neutron/neutron.conf</literal> :</simpara>
          <screen># We bind the service to the VIP:
bind_host = 192.168.42.103

# We bind OpenStack Networking Server to the VIP:
bind_host = 192.168.42.103

# We send notifications to Highly available RabbitMQ:
notifier_strategy = rabbit
rabbit_host = 192.168.42.102

[database]
# We have to use MySQL connection to store data:
connection = mysql://neutron:password@192.168.42.101/neutron</screen>
        </section>
        <section xml:id="_configure_openstack_services_to_use_highly_available_openstack_networking_server">
          <info>
            <title>Configure OpenStack services to use highly available OpenStack Networking server</title>
          </info>
          <simpara>Your OpenStack services must now point their OpenStack Networking Server configuration to
the highly available, virtual cluster IP address — rather than an
OpenStack Networking server’s physical IP address as you normally would.</simpara>
          <simpara>For example, you should configure OpenStack Compute for using highly available OpenStack Networking server in editing <literal>nova.conf</literal> file:</simpara>
          <screen>neutron_url = http://192.168.42.103:9696</screen>
          <simpara>You need to create the OpenStack Networking server endpoint with this IP.</simpara>
          <note>
            <simpara>If you are using both private and public IP addresses, you should create two Virtual IP addresses and define your endpoint like this:</simpara>
          </note>
          <screen>keystone endpoint-create --region $KEYSTONE_REGION --service-id $service-id --publicurl 'http://PUBLIC_VIP:9696/' --adminurl 'http://192.168.42.103:9696/' --internalurl 'http://192.168.42.103:9696/'</screen>
        </section>
      </section>
      <section xml:id="s-ceilometer-agent-central">
        <info>
          <title>Highly available Telemetry central agent</title>
        </info>
        <simpara>Telemetry (ceilometer) is the metering and monitoring service in
OpenStack.  The Central agent polls for resource utilization
statistics for resources not tied to instances or compute nodes.</simpara>
        <note>
          <simpara>Due to limitations of a polling model, a single instance of this agent
can be polling a given list of meters. In this setup, we install this service
on the API nodes also in the active / passive mode.</simpara>
        </note>
        <simpara>Making the Telemetry central agent service highly available in active / passive mode involves
managing its daemon with the Pacemaker cluster manager.</simpara>
        <note>
          <simpara>You will find at <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.openstack.org/developer/ceilometer/install/manual.html#installing-the-central-agent">this page</link>
the process to install the Telemetry central agent.</simpara>
        </note>
        <section xml:id="_add_the_telemetry_central_agent_resource_to_pacemaker">
          <info>
            <title>Add the Telemetry central agent resource to Pacemaker</title>
          </info>
          <simpara>First of all, you need to download the resource agent to your system:</simpara>
          <screen>cd /usr/lib/ocf/resource.d/openstack
wget https://raw.github.com/madkiss/openstack-resource-agents/master/ocf/ceilometer-agent-central
chmod a+rx *</screen>
          <simpara>You may then proceed with adding the Pacemaker configuration for
the Telemetry central agent resource. Connect to the Pacemaker cluster with <literal>crm
configure</literal>, and add the following cluster resources:</simpara>
          <screen>primitive p_ceilometer-agent-central ocf:openstack:ceilometer-agent-central \
    params config="/etc/ceilometer/ceilometer.conf" \
    op monitor interval="30s" timeout="30s"</screen>
          <simpara>This configuration creates</simpara>
          <itemizedlist>
            <listitem>
              <simpara><literal>p_ceilometer-agent-central</literal>, a resource for manage Ceilometer Central Agent service
</simpara>
            </listitem>
          </itemizedlist>
          <simpara><literal>crm configure</literal> supports batch input, so you may copy and paste the
above into your live pacemaker configuration, and then make changes as
required.</simpara>
          <simpara>Once completed, commit your configuration changes by entering <literal>commit</literal>
from the <literal>crm configure</literal> menu. Pacemaker will then start the Ceilometer Central Agent
service, and its dependent resources, on one of your nodes.</simpara>
        </section>
        <section xml:id="_configure_telemetry_central_agent_service">
          <info>
            <title>Configure Telemetry central agent service</title>
          </info>
          <simpara>Edit <literal>/etc/ceilometer/ceilometer.conf</literal> :</simpara>
          <screen># We use API VIP for Identity Service connection :
os_auth_url=http://192.168.42.103:5000/v2.0

# We send notifications to High Available RabbitMQ :
notifier_strategy = rabbit
rabbit_host = 192.168.42.102

[database]
# We have to use MySQL connection to store data :
sql_connection=mysql://ceilometer:password@192.168.42.101/ceilometer</screen>
        </section>
      </section>
      <section xml:id="s-api-pacemaker">
        <info>
          <title>Configure Pacemaker group</title>
        </info>
        <simpara>Finally, we need to create a service <literal>group</literal> to ensure that virtual IP is linked to the API services resources:</simpara>
        <screen>group g_services_api p_api-ip p_keystone p_glance-api p_cinder-api \
   p_neutron-server p_glance-registry p_ceilometer-agent-central</screen>
      </section>
    </section>
    <section xml:id="ch-network">
      <info>
        <title>Network controller cluster stack</title>
      </info>
      <simpara>The network controller sits on the management and data network, and needs to be connected to the Internet if a VM needs access to it.</simpara>
      <note>
        <simpara>Both nodes should have the same hostname since the Networking scheduler will be
aware of one node, for example a virtual router attached to a single L3 node.</simpara>
      </note>
      <section xml:id="_highly_available_neutron_l3_agent">
        <info>
          <title>Highly available neutron L3 agent</title>
        </info>
        <simpara>The neutron L3 agent provides L3/NAT forwarding to ensure external network access
for VMs on tenant networks. High availability for the L3 agent is achieved by
adopting Pacemaker.</simpara>
        <note>
          <simpara>Here is the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.openstack.org/trunk/config-reference/content/section_adv_cfg_l3_agent.html">documentation</link> for installing neutron L3 agent.</simpara>
        </note>
        <section xml:id="_add_neutron_l3_agent_resource_to_pacemaker">
          <info>
            <title>Add neutron L3 agent resource to Pacemaker</title>
          </info>
          <simpara>First of all, you need to download the resource agent to your system:</simpara>
          <screen>cd /usr/lib/ocf/resource.d/openstack
wget https://raw.github.com/madkiss/openstack-resource-agents/master/ocf/neutron-agent-l3
chmod a+rx neutron-l3-agent</screen>
          <simpara>You may now proceed with adding the Pacemaker configuration for
neutron L3 agent resource. Connect to the Pacemaker cluster with <literal>crm
configure</literal>, and add the following cluster resources:</simpara>
          <screen>primitive p_neutron-l3-agent ocf:openstack:neutron-agent-l3 \
    params config="/etc/neutron/neutron.conf" \
    plugin_config="/etc/neutron/l3_agent.ini" \
    op monitor interval="30s" timeout="30s"</screen>
          <simpara>This configuration creates</simpara>
          <itemizedlist>
            <listitem>
              <simpara><literal>p_neutron-l3-agent</literal>, a resource for manage Neutron L3 Agent service
</simpara>
            </listitem>
          </itemizedlist>
          <simpara><literal>crm configure</literal> supports batch input, so you may copy and paste the
above into your live pacemaker configuration, and then make changes as
required.</simpara>
          <simpara>Once completed, commit your configuration changes by entering <literal>commit</literal>
from the <literal>crm configure</literal> menu. Pacemaker will then start the neutron L3 agent
service, and its dependent resources, on one of your nodes.</simpara>
          <note>
            <simpara>This method does not ensure a zero downtime since it has to recreate all
the namespaces and virtual routers on the node.</simpara>
          </note>
        </section>
      </section>
      <section xml:id="_highly_available_neutron_dhcp_agent">
        <info>
          <title>Highly available neutron DHCP agent</title>
        </info>
        <simpara>Neutron DHCP agent distributes IP addresses to the VMs with dnsmasq (by
default). High availability for the DHCP agent is achieved by adopting
Pacemaker.</simpara>
        <note>
          <simpara>Here is the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.openstack.org/trunk/config-reference/content/section_adv_cfg_dhcp_agent.html">documentation</link> for installing neutron DHCP agent.</simpara>
        </note>
        <section xml:id="_add_neutron_dhcp_agent_resource_to_pacemaker">
          <info>
            <title>Add neutron DHCP agent resource to Pacemaker</title>
          </info>
          <simpara>First of all, you need to download the resource agent to your system:</simpara>
          <screen>cd /usr/lib/ocf/resource.d/openstack
wget https://raw.github.com/madkiss/openstack-resource-agents/master/ocf/neutron-agent-dhcp
chmod a+rx neutron-dhcp-agent</screen>
          <simpara>You may now proceed with adding the Pacemaker configuration for
neutron DHCP agent resource. Connect to the Pacemaker cluster with <literal>crm
configure</literal>, and add the following cluster resources:</simpara>
          <screen>primitive p_neutron-dhcp-agent ocf:openstack:neutron-dhcp-agent \
    params config="/etc/neutron/neutron.conf" \
    plugin_config="/etc/neutron/dhcp_agent.ini" \
    op monitor interval="30s" timeout="30s"</screen>
          <simpara>This configuration creates</simpara>
          <itemizedlist>
            <listitem>
              <simpara><literal>p_neutron-dhcp-agent</literal>, a resource for manage Neutron DHCP Agent
service
</simpara>
            </listitem>
          </itemizedlist>
          <simpara><literal>crm configure</literal> supports batch input, so you may copy and paste the
above into your live pacemaker configuration, and then make changes as
required.</simpara>
          <simpara>Once completed, commit your configuration changes by entering <literal>commit</literal>
from the <literal>crm configure</literal> menu. Pacemaker will then start the neutron DHCP
agent service, and its dependent resources, on one of your nodes.</simpara>
        </section>
      </section>
      <section xml:id="_highly_available_neutron_metadata_agent">
        <info>
          <title>Highly available neutron metadata agent</title>
        </info>
        <simpara>Neutron metadata agent allows Compute API metadata to be reachable by VMs on tenant
networks. High availability for the metadata agent is achieved by adopting
Pacemaker.</simpara>
        <note>
          <simpara>Here is the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.openstack.org/trunk/config-reference/content/networking-options-metadata.html">documentation</link> for installing Neutron Metadata Agent.</simpara>
        </note>
        <section xml:id="_add_neutron_metadata_agent_resource_to_pacemaker">
          <info>
            <title>Add neutron metadata agent resource to Pacemaker</title>
          </info>
          <simpara>First of all, you need to download the resource agent to your system:</simpara>
          <screen>cd /usr/lib/ocf/resource.d/openstack
wget https://raw.github.com/madkiss/openstack-resource-agents/master/ocf/neutron-metadata-agent
chmod a+rx neutron-metadata-agent</screen>
          <simpara>You may now proceed with adding the Pacemaker configuration for
neutron metadata agent resource. Connect to the Pacemaker cluster with <literal>crm
configure</literal>, and add the following cluster resources:</simpara>
          <screen>primitive p_neutron-metadata-agent ocf:openstack:neutron-metadata-agent \
    params config="/etc/neutron/neutron.conf" \
    plugin_config="/etc/neutron/metadata_agent.ini" \
    op monitor interval="30s" timeout="30s"</screen>
          <simpara>This configuration creates</simpara>
          <itemizedlist>
            <listitem>
              <simpara><literal>p_neutron-metadata-agent</literal>, a resource for manage Neutron Metadata Agent
service
</simpara>
            </listitem>
          </itemizedlist>
          <simpara><literal>crm configure</literal> supports batch input, so you may copy and paste the
above into your live pacemaker configuration, and then make changes as
required.</simpara>
          <simpara>Once completed, commit your configuration changes by entering <literal>commit</literal>
from the <literal>crm configure</literal> menu. Pacemaker will then start the neutron metadata
agent service, and its dependent resources, on one of your nodes.</simpara>
        </section>
      </section>
      <section xml:id="_manage_network_resources">
        <info>
          <title>Manage network resources</title>
        </info>
        <simpara>You can now add the Pacemaker configuration for
managing all network resources together with a group.
Connect to the Pacemaker cluster with <literal>crm configure</literal>, and add the following
cluster resources:</simpara>
        <screen>group g_services_network p_neutron-l3-agent p_neutron-dhcp-agent \
    p_neutron-metadata_agent</screen>
      </section>
    </section>
  </chapter>
  <chapter xml:id="ha-using-active-active">
    <info>
      <title>HA using active/active</title>
    </info>
    <section xml:id="ha-aa-db">
      <info>
        <title>Database</title>
      </info>
      <simpara>The first step is installing the database that sits at the heart of the
cluster.  When we talk about High Availability, we talk about several databases (for redundancy) and a
means to keep them synchronized.  In this case, we must choose the
MySQL database, along with Galera for synchronous multi-master replication.</simpara>
      <simpara>The choice of database isn’t a foregone conclusion; you’re not required
to use MySQL.  It is, however, a fairly common choice in OpenStack
installations, so we’ll cover it here.</simpara>
      <section xml:id="ha-aa-db-mysql-galera">
        <info>
          <title>MySQL with Galera</title>
        </info>
        <simpara>Rather than starting with a vanilla version of MySQL, and then adding
Galera, you will want to install a version of MySQL patched for wsrep
(Write Set REPlication) from <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://launchpad.net/codership-mysql/0.7">https://launchpad.net/codership-mysql/0.7</link>.
The wsrep API is suitable for configuring MySQL High Availability in
OpenStack because it supports synchronous replication.</simpara>
        <simpara>Note that the installation requirements call for careful attention. Read
the guide <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://launchpadlibrarian.net/66669857/README-wsrep">https://launchpadlibrarian.net/66669857/README-wsrep</link>
to ensure you follow all the required steps.</simpara>
        <orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts">
          <info>
            <title>Installing Galera through a MySQL version patched for wsrep:</title>
          </info>
          <listitem>
            <simpara>
Download Galera from <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://launchpad.net/galera/+download">https://launchpad.net/galera/+download</link>, and
  install the *.rpms or *.debs, which takes care of any dependencies
  that your system doesn’t already have installed.
</simpara>
          </listitem>
          <listitem>
            <simpara>
Adjust the configuration:
</simpara>
        <simpara>In the system-wide <literal>my.conf</literal> file, make sure mysqld isn’t bound to
127.0.0.1, and that <literal>/etc/mysql/conf.d/</literal> is included.
Typically you can find this file at <literal>/etc/my.cnf</literal>:</simpara>
        <screen>[mysqld]
...
!includedir /etc/mysql/conf.d/
...
#bind-address = 127.0.0.1</screen>
        <simpara>When adding a new node, you must configure it with a MySQL account that
can access the other nodes. The new node must be able to request a state
snapshot from one of the existing nodes:</simpara>
          </listitem>
          <listitem>
            <simpara>
Specify your MySQL account information in <literal>/etc/mysql/conf.d/wsrep.cnf</literal>:
</simpara>
        <screen>wsrep_sst_auth=wsrep_sst:wspass</screen>
          </listitem>
          <listitem>
            <simpara>
Connect as root and grant privileges to that user:
</simpara>
        <screen>$ mysql -e "SET wsrep_on=OFF; GRANT ALL ON *.* TO wsrep_sst@'%' IDENTIFIED BY 'wspass'";</screen>
          </listitem>
          <listitem>
            <simpara>
Remove user accounts with empty usernames because they cause problems:
</simpara>
        <screen>$ mysql -e "SET wsrep_on=OFF; DELETE FROM mysql.user WHERE user='';"</screen>
          </listitem>
          <listitem>
            <simpara>
Set up certain mandatory configuration options within MySQL itself.
These include:
</simpara>
        <screen>query_cache_size=0
binlog_format=ROW
default_storage_engine=innodb
innodb_autoinc_lock_mode=2
innodb_doublewrite=1</screen>
          </listitem>
          <listitem>
            <simpara>
Check that the nodes can access each other through the firewall.
Depending on your environment, this might mean adjusting iptables, as in:
</simpara>
        <screen># iptables --insert RH-Firewall-1-INPUT 1 --proto tcp --source &lt;my IP&gt;/24 --destination &lt;my IP&gt;/32 --dport 3306 -j ACCEPT
# iptables --insert RH-Firewall-1-INPUT 1 --proto tcp --source &lt;my IP&gt;/24 --destination &lt;my IP&gt;/32 --dport 4567 -j ACCEPT</screen>
        <simpara>This might also mean configuring any NAT firewall between nodes to allow
direct connections. You might need to disable SELinux, or configure it to
allow mysqld to listen to sockets at unprivileged ports.</simpara>
          </listitem>
        </orderedlist>
        <simpara>Now you’re ready to create the cluster.</simpara>
        <section xml:id="_create_the_cluster">
          <info>
            <title>Create the cluster</title>
          </info>
          <simpara>In creating a cluster, you first start a single instance, which creates
the cluster. The rest of the MySQL instances then connect to
that cluster:</simpara>
          <orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts">
            <info>
              <title>An example of creating the cluster:</title>
            </info>
            <listitem>
              <simpara>
Start on <literal>10.0.0.10</literal> by executing the command:
</simpara>
            </listitem>
          </orderedlist>
          <screen># service mysql start wsrep_cluster_address=gcomm://</screen>
          <orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts">
            <listitem>
              <simpara>
Connect to that cluster on the rest of the nodes by referencing the
address of that node, as in:
</simpara>
            </listitem>
          </orderedlist>
          <screen># service mysql start wsrep_cluster_address=gcomm://10.0.0.10</screen>
          <simpara>You also have the option to set the <literal>wsrep_cluster_address</literal> in the
<literal>/etc/mysql/conf.d/wsrep.cnf</literal> file, or within the client itself.  (In
fact, for some systems, such as MariaDB or Percona, this may be your
only option.)</simpara>
          <orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts">
            <info>
              <title>An example of checking the status of the cluster.</title>
            </info>
            <listitem>
              <simpara>
Open the MySQL client and check the status of the various parameters:
</simpara>
            </listitem>
          </orderedlist>
          <screen>mysql&gt; SET GLOBAL wsrep_cluster_address='&lt;cluster address string&gt;';
mysql&gt; SHOW STATUS LIKE 'wsrep%';</screen>
          <simpara>You should see a status that looks something like this:</simpara>
          <screen>mysql&gt; show status like 'wsrep%';
+----------------------------+--------------------------------------+
| Variable_name              | Value                                |
+----------------------------+--------------------------------------+
| wsrep_local_state_uuid     | 111fc28b-1b05-11e1-0800-e00ec5a7c930 |
| wsrep_protocol_version     | 1                                    |
| wsrep_last_committed       | 0                                    |
| wsrep_replicated           | 0                                    |
| wsrep_replicated_bytes     | 0                                    |
| wsrep_received             | 2                                    |
| wsrep_received_bytes       | 134                                  |
| wsrep_local_commits        | 0                                    |
| wsrep_local_cert_failures  | 0                                    |
| wsrep_local_bf_aborts      | 0                                    |
| wsrep_local_replays        | 0                                    |
| wsrep_local_send_queue     | 0                                    |
| wsrep_local_send_queue_avg | 0.000000                             |
| wsrep_local_recv_queue     | 0                                    |
| wsrep_local_recv_queue_avg | 0.000000                             |
| wsrep_flow_control_paused  | 0.000000                             |
| wsrep_flow_control_sent    | 0                                    |
| wsrep_flow_control_recv    | 0                                    |
| wsrep_cert_deps_distance   | 0.000000                             |
| wsrep_apply_oooe           | 0.000000                             |
| wsrep_apply_oool           | 0.000000                             |
| wsrep_apply_window         | 0.000000                             |
| wsrep_commit_oooe          | 0.000000                             |
| wsrep_commit_oool          | 0.000000                             |
| wsrep_commit_window        | 0.000000                             |
| wsrep_local_state          | 4                                    |
| wsrep_local_state_comment  | Synced (6)                           |
| wsrep_cert_index_size      | 0                                    |
| wsrep_cluster_conf_id      | 1                                    |
| wsrep_cluster_size         | 1                                    |
| wsrep_cluster_state_uuid   | 111fc28b-1b05-11e1-0800-e00ec5a7c930 |
| wsrep_cluster_status       | Primary                              |
| wsrep_connected            | ON                                   |
| wsrep_local_index          | 0                                    |
| wsrep_provider_name        | Galera                               |
| wsrep_provider_vendor      | Codership Oy                         |
| wsrep_provider_version     | 21.1.0(r86)                          |
| wsrep_ready                | ON                                   |
+----------------------------+--------------------------------------+
38 rows in set (0.01 sec)</screen>
        </section>
      </section>
      <section xml:id="ha-aa-db-galera-monitoring">
        <info>
          <title>Galera monitoring scripts</title>
        </info>
        <simpara>(Coming soon)</simpara>
      </section>
      <section xml:id="_other_ways_to_provide_a_highly_available_database">
        <info>
          <title>Other ways to provide a highly available database</title>
        </info>
        <simpara>MySQL with Galera is by no means the only way to achieve database HA.
MariaDB (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="https://mariadb.org/">https://mariadb.org/</link>) and Percona (<link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.percona.com/">http://www.percona.com/</link>)
also work with Galera. You also have the option to use Postgres, which
has its own replication, or another database HA option.</simpara>
      </section>
    </section>
    <section xml:id="ha-aa-rabbitmq">
      <info>
        <title>RabbitMQ</title>
      </info>
      <simpara>RabbitMQ is the default AMQP server used by many OpenStack services. Making the RabbitMQ service
highly available involves the following steps:</simpara>
      <itemizedlist>
        <listitem>
          <simpara>
Install RabbitMQ
</simpara>
        </listitem>
        <listitem>
          <simpara>
Configure RabbitMQ for HA queues
</simpara>
        </listitem>
        <listitem>
          <simpara>
Configure OpenStack services to use Rabbit HA queues
</simpara>
        </listitem>
      </itemizedlist>
      <section xml:id="_install_rabbitmq">
        <info>
          <title>Install RabbitMQ</title>
        </info>
        <simpara>This setup has been tested with RabbitMQ 2.7.1.</simpara>
        <section xml:id="_on_ubuntu_debian">
          <info>
            <title>On Ubuntu / Debian</title>
          </info>
          <simpara>RabbitMQ is packaged on both distros:</simpara>
          <screen>apt-get install rabbitmq-server rabbitmq-plugins</screen>
          <simpara>
            <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.rabbitmq.com/install-debian.html">Official manual for installing RabbitMQ on Ubuntu / Debian</link>
          </simpara>
        </section>
        <section xml:id="_on_fedora_rhel">
          <info>
            <title>On Fedora / RHEL</title>
          </info>
          <simpara>RabbitMQ is packaged on both distros:</simpara>
          <screen>yum install erlang</screen>
          <simpara>
            <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.rabbitmq.com/install-rpm.html">Official manual for installing RabbitMQ on Fedora / RHEL</link>
          </simpara>
        </section>
      </section>
      <section xml:id="_configure_rabbitmq">
        <info>
          <title>Configure RabbitMQ</title>
        </info>
        <simpara>Here we are building a cluster of RabbitMQ nodes to construct a RabbitMQ broker.
Mirrored queues in RabbitMQ improve the availability of service since it will be resilient to failures.
We have to consider that while exchanges and bindings will survive the loss of individual nodes, queues
and their messages will not because a queue and its contents is located on one node. If we lose this node,
we also lose the queue.</simpara>
        <simpara>We consider that we run (at least) two RabbitMQ servers. To build a broker, we need to ensure that all nodes
have the same erlang cookie file. To do so, stop RabbitMQ everywhere and copy the cookie from rabbit1 server
to other server(s):</simpara>
        <screen>scp /var/lib/rabbitmq/.erlang.cookie \
root@rabbit2:/var/lib/rabbitmq/.erlang.cookie</screen>
        <simpara>Then, start RabbitMQ on nodes.
If RabbitMQ fails to start, you can’t continue to the next step.</simpara>
        <simpara>Now, we are building the HA cluster. From rabbit2, run these commands:</simpara>
        <screen>rabbitmqctl stop_app
rabbitmqctl cluster rabbit@rabbit1
rabbitmqctl start_app</screen>
        <simpara>To verify the cluster status :</simpara>
        <screen>rabbitmqctl cluster_status

Cluster status of node rabbit@rabbit2 ...
[{nodes,[{disc,[rabbit@rabbit1]},{ram,[rabbit@rabbit2]}]},{running_nodes,[rabbit@rabbit2,rabbit@rabbit1]}]</screen>
        <simpara>If the cluster is working, you can now proceed to creating users and passwords for queues.</simpara>
        <simpara>
          <emphasis role="strong">Note for RabbitMQ version 3</emphasis>
        </simpara>
        <simpara>Queue mirroring is no longer controlled by the <emphasis>x-ha-policy</emphasis> argument when declaring a queue. OpenStack can
continue to declare this argument, but it won’t cause queues to be mirrored.
We need to make sure that all queues (except those with auto-generated names) are mirrored across all running nodes:</simpara>
        <screen>rabbitmqctl set_policy HA '^(?!amq\.).*' '{"ha-mode": "all"}'</screen>
        <simpara>
          <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://www.rabbitmq.com/ha.html">More information about High availability in RabbitMQ</link>
        </simpara>
      </section>
      <section xml:id="_configure_openstack_services_to_use_rabbitmq">
        <info>
          <title>Configure OpenStack services to use RabbitMQ</title>
        </info>
        <simpara>We have to configure the OpenStack components to use at least two RabbitMQ nodes.</simpara>
        <simpara>Do this configuration on all services using RabbitMQ:</simpara>
        <simpara>RabbitMQ HA cluster host:port pairs:</simpara>
        <screen>rabbit_hosts=rabbit1:5672,rabbit2:5672</screen>
        <simpara>How frequently to retry connecting with RabbitMQ:</simpara>
        <screen>rabbit_retry_interval=1</screen>
        <simpara>How long to back-off for between retries when connecting to RabbitMQ:</simpara>
        <screen>rabbit_retry_backoff=2</screen>
        <simpara>Maximum retries with trying to connect to RabbitMQ (infinite by default):</simpara>
        <screen>rabbit_max_retries=0</screen>
        <simpara>Use durable queues in RabbitMQ:</simpara>
        <screen>rabbit_durable_queues=false</screen>
        <simpara>Use H/A queues in RabbitMQ (x-ha-policy: all):</simpara>
        <screen>rabbit_ha_queues=true</screen>
        <simpara>If you change the configuration from an old setup which did not use HA queues, you should interrupt the service:</simpara>
        <screen>rabbitmqctl stop_app
rabbitmqctl reset
rabbitmqctl start_app</screen>
        <simpara>Services currently working with HA queues: OpenStack Compute, OpenStack Block Storage, OpenStack Networking, Telemetry.</simpara>
      </section>
    </section>
    <section xml:id="ha-aa-haproxy">
      <info>
        <title>HAproxy nodes</title>
      </info>
      <simpara>HAProxy is a very fast and reliable solution offering high availability, load balancing, and proxying
for TCP and HTTP-based applications. It is particularly suited for web sites crawling under very high loads
while needing persistence or Layer 7 processing. Supporting tens of thousands of connections is clearly
realistic with today’s hardware.</simpara>
      <simpara>For installing HAproxy on your nodes, you should consider its <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://haproxy.1wt.eu/#docs">official documentation</link>.
Also, you have to consider that this service should not be a single point of failure, so you need at least two
nodes running HAproxy.</simpara>
      <simpara>Here is an example for HAproxy configuration file:</simpara>
      <screen>global
  chroot  /var/lib/haproxy
  daemon
  group  haproxy
  maxconn  4000
  pidfile  /var/run/haproxy.pid
  user  haproxy

defaults
  log  global
  maxconn  8000
  option  redispatch
  retries  3
  timeout  http-request 10s
  timeout  queue 1m
  timeout  connect 10s
  timeout  client 1m
  timeout  server 1m
  timeout  check 10s

listen dashboard_cluster
  bind &lt;Virtual IP&gt;:443
  balance  source
  option  tcpka
  option  httpchk
  option  tcplog
  server controller1 10.0.0.1:443 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:443 check inter 2000 rise 2 fall 5

listen galera_cluster
  bind &lt;Virtual IP&gt;:3306
  balance  source
  option  httpchk
  server controller1 10.0.0.4:3306 check port 9200 inter 2000 rise 2 fall 5
  server controller2 10.0.0.5:3306 check port 9200 inter 2000 rise 2 fall 5
  server controller3 10.0.0.6:3306 check port 9200 inter 2000 rise 2 fall 5

listen glance_api_cluster
  bind &lt;Virtual IP&gt;:9292
  balance  source
  option  tcpka
  option  httpchk
  option  tcplog
  server controller1 10.0.0.1:9292 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:9292 check inter 2000 rise 2 fall 5

listen glance_registry_cluster
  bind &lt;Virtual IP&gt;:9191
  balance  source
  option  tcpka
  option  tcplog
  server controller1 10.0.0.1:9191 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:9191 check inter 2000 rise 2 fall 5

listen keystone_admin_cluster
  bind &lt;Virtual IP&gt;:35357
  balance  source
  option  tcpka
  option  httpchk
  option  tcplog
  server controller1 10.0.0.1:35357 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2.42:35357 check inter 2000 rise 2 fall 5

listen keystone_public_internal_cluster
  bind &lt;Virtual IP&gt;:5000
  balance  source
  option  tcpka
  option  httpchk
  option  tcplog
  server controller1 10.0.0.1:5000 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:5000 check inter 2000 rise 2 fall 5

listen nova_ec2_api_cluster
  bind &lt;Virtual IP&gt;:8773
  balance  source
  option  tcpka
  option  tcplog
  server controller1 10.0.0.1:8773 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:8773 check inter 2000 rise 2 fall 5

listen nova_compute_api_cluster
  bind &lt;Virtual IP&gt;:8774
  balance  source
  option  tcpka
  option  httpchk
  option  tcplog
  server controller1 10.0.0.1:8774 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:8774 check inter 2000 rise 2 fall 5

listen nova_metadata_api_cluster
  bind &lt;Virtual IP&gt;:8775
  balance  source
  option  tcpka
  option  tcplog
  server controller1 10.0.0.1:8775 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:8775 check inter 2000 rise 2 fall 5

listen cinder_api_cluster
  bind &lt;Virtual IP&gt;:8776
  balance  source
  option  tcpka
  option  httpchk
  option  tcplog
  server controller1 10.0.0.1:8776 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:8776 check inter 2000 rise 2 fall 5

listen ceilometer_api_cluster
  bind &lt;Virtual IP&gt;:8777
  balance  source
  option  tcpka
  option  httpchk
  option  tcplog
  server controller1 10.0.0.1:8774 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:8774 check inter 2000 rise 2 fall 5

listen spice_cluster
  bind &lt;Virtual IP&gt;:6082
  balance  source
  option  tcpka
  option  tcplog
  server controller1 10.0.0.1:6080 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:6080 check inter 2000 rise 2 fall 5

listen neutron_api_cluster
  bind &lt;Virtual IP&gt;:9696
  balance  source
  option  tcpka
  option  httpchk
  option  tcplog
  server controller1 10.0.0.1:9696 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:9696 check inter 2000 rise 2 fall 5

listen swift_proxy_cluster
  bind &lt;Virtual IP&gt;:8080
  balance  source
  option  tcplog
  option  tcpka
  server controller1 10.0.0.1:8080 check inter 2000 rise 2 fall 5
  server controller2 10.0.0.2:8080 check inter 2000 rise 2 fall 5</screen>
      <simpara>After each change of this file, you should restart HAproxy.</simpara>
    </section>
    <section xml:id="ha-aa-controllers">
      <info>
        <title>OpenStack controller nodes</title>
      </info>
      <simpara>OpenStack controller nodes contain:</simpara>
      <itemizedlist>
        <listitem>
          <simpara>
All OpenStack API services
</simpara>
        </listitem>
        <listitem>
          <simpara>
All OpenStack schedulers
</simpara>
        </listitem>
        <listitem>
          <simpara>
Memcached service
</simpara>
        </listitem>
      </itemizedlist>
      <section xml:id="_run_openstack_api_and_schedulers">
        <info>
          <title>Run OpenStack API and schedulers</title>
        </info>
        <section xml:id="_api_services">
          <info>
            <title>API services</title>
          </info>
          <simpara>All OpenStack projects have an API service for controlling all the resources in the Cloud.
In Active / Active mode, the most common setup is to scale-out these services on at least two nodes
and use load-balancing and virtual IP (with HAproxy &amp; Keepalived in this setup).</simpara>
          <simpara>
            <emphasis role="strong">Configure API OpenStack services</emphasis>
          </simpara>
          <simpara>To configure our Cloud using Highly available and scalable API services, we need to ensure that:</simpara>
          <itemizedlist>
            <listitem>
              <simpara>
You use Virtual IP when configuring OpenStack Identity endpoints.
</simpara>
            </listitem>
            <listitem>
              <simpara>
All OpenStack configuration files should refer to Virtual IP.
</simpara>
            </listitem>
          </itemizedlist>
          <simpara>
            <emphasis role="strong">In case of failure</emphasis>
          </simpara>
          <simpara>The monitor check is quite simple since it just establishes a TCP connection to the API port. Comparing to the
Active / Passive mode using Corosync &amp; Resources Agents, we don’t check if the service is actually running).
That’s why all OpenStack API should be monitored by another tool (i.e. Nagios) with the goal to detect
failures in the Cloud Framework infrastructure.</simpara>
        </section>
        <section xml:id="_schedulers">
          <info>
            <title>Schedulers</title>
          </info>
          <simpara>OpenStack schedulers are used to determine how to dispatch compute, network and volume requests. The most
common setup is to use RabbitMQ as messaging system already documented in this guide.
Those services are connected to the messaging backend and can scale-out :</simpara>
          <itemizedlist>
            <listitem>
              <simpara>
nova-scheduler
</simpara>
            </listitem>
            <listitem>
              <simpara>
nova-conductor
</simpara>
            </listitem>
            <listitem>
              <simpara>
cinder-scheduler
</simpara>
            </listitem>
            <listitem>
              <simpara>
neutron-server
</simpara>
            </listitem>
            <listitem>
              <simpara>
ceilometer-collector
</simpara>
            </listitem>
            <listitem>
              <simpara>
heat-engine
</simpara>
            </listitem>
          </itemizedlist>
          <simpara>Please refer to the RabbitMQ section for configure these services with multiple messaging servers.</simpara>
        </section>
      </section>
      <section xml:id="_memcached">
        <info>
          <title>Memcached</title>
        </info>
        <simpara>Most of OpenStack services use an application to offer persistence and store ephemeral data (like tokens).
Memcached is one of them and can scale-out easily without specific trick.</simpara>
        <simpara>To install and configure it, read the <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://code.google.com/p/memcached/wiki/NewStart">official documentation</link>.</simpara>
        <simpara>Memory caching is managed by oslo-incubator so the way to use multiple memcached servers is the same for all projects.</simpara>
        <simpara>Example with two hosts:</simpara>
        <screen>memcached_servers = controller1:11211,controller2:11211</screen>
        <simpara>By default, controller1 handles the caching service but if the host goes down, controller2 does the job.
For more information about memcached installation, see the OpenStack
Cloud Administrator Guide.</simpara>
      </section>
    </section>
    <section xml:id="ha-aa-network">
      <info>
        <title>OpenStack network nodes</title>
      </info>
      <simpara>OpenStack network nodes contain:</simpara>
      <itemizedlist>
        <listitem>
          <simpara>
neutron DHCP agent
</simpara>
        </listitem>
        <listitem>
          <simpara>
neutron L2 agent
</simpara>
        </listitem>
        <listitem>
          <simpara>
Neutron L3 agent
</simpara>
        </listitem>
        <listitem>
          <simpara>
neutron metadata agent
</simpara>
        </listitem>
        <listitem>
          <simpara>
neutron lbaas agent
</simpara>
        </listitem>
      </itemizedlist>
      <note>
        <simpara>The neutron L2 agent does not need to be highly available. It has to be
installed on each Data Forwarding Node and controls the virtual networking
drivers as Open vSwitch or Linux Bridge. One L2 agent runs per node
and controls its virtual interfaces. That’s why it cannot be distributed and
highly available.</simpara>
      </note>
      <section xml:id="_run_neutron_dhcp_agent">
        <info>
          <title>Run neutron DHCP agent</title>
        </info>
        <simpara>OpenStack Networking service has a scheduler that
lets you run multiple agents across nodes. Also, the DHCP agent can be natively
highly available. For details, see <link xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="http://docs.openstack.org/trunk/config-reference/content/app_demo_multi_dhcp_agents.html">OpenStack Configuration Reference</link>.</simpara>
      </section>
      <section xml:id="_run_neutron_l3_agent">
        <info>
          <title>Run neutron L3 agent</title>
        </info>
        <simpara>The neutron L3 agent is scalable thanks to the scheduler
that allows distribution of virtual routers across multiple nodes.
But there is no native feature to make these routers highly available.
At this time, the Active / Passive solution exists to run the Neutron L3
agent in failover mode with Pacemaker. See the Active / Passive
section of this guide.</simpara>
      </section>
      <section xml:id="_run_neutron_metadata_agent">
        <info>
          <title>Run neutron metadata agent</title>
        </info>
        <simpara>There is no native feature to make this service highly available.
At this time, the Active / Passive solution exists to run the neutron
metadata agent in failover mode with Pacemaker. See the Active /
Passive section of this guide.</simpara>
      </section>
    </section>
  </chapter>
</book>
